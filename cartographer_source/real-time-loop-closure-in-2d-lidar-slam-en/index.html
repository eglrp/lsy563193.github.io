<!DOCTYPE html>




<html class="theme-next mist" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/lin-oracle.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/lin-oracle.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/lin-oracle.png?v=5.1.4">


  <link rel="mask-icon" href="/images/lin-oracle.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="林少岳" />





  <link rel="alternate" href="/atom.xml" title="林少岳的博客" type="application/atom+xml" />






<meta name="description" content="Real-Time Loop Closure in 2D LIDAR SLAM Abstract 摘要Portable laser range-finders, further referred to as LIDAR, and simultaneous localization and mapping (SLAM) are an efficient method of acquiring as-">
<meta property="og:type" content="article">
<meta property="og:title" content="林少岳的博客">
<meta property="og:url" content="http://lsy563193.github.io/cartographer_source/real-time-loop-closure-in-2d-lidar-slam-en/index.html">
<meta property="og:site_name" content="林少岳的博客">
<meta property="og:description" content="Real-Time Loop Closure in 2D LIDAR SLAM Abstract 摘要Portable laser range-finders, further referred to as LIDAR, and simultaneous localization and mapping (SLAM) are an efficient method of acquiring as-">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://lsy563193.github.io/home/syue/github/cartographer-notes/docs/asset/carto_submap.png">
<meta property="og:updated_time" content="2018-10-30T01:49:26.209Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="林少岳的博客">
<meta name="twitter:description" content="Real-Time Loop Closure in 2D LIDAR SLAM Abstract 摘要Portable laser range-finders, further referred to as LIDAR, and simultaneous localization and mapping (SLAM) are an efficient method of acquiring as-">
<meta name="twitter:image" content="http://lsy563193.github.io/home/syue/github/cartographer-notes/docs/asset/carto_submap.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://lsy563193.github.io/cartographer_source/real-time-loop-closure-in-2d-lidar-slam-en/"/>





  <title> | 林少岳的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">林少岳的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学而不思则罔 思而不学则殆</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://lsy563193.github.io/cartographer_source/real-time-loop-closure-in-2d-lidar-slam-en/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ShaoYue Lin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/4884007?s=400&u=af3c3a113957bd20c7f2b0102773570000f7b48a&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林少岳的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-30T09:49:26+08:00">
                2018-10-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,157
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Real-Time Loop Closure in 2D LIDAR SLAM</p>
<h2 id="Abstract-摘要"><a href="#Abstract-摘要" class="headerlink" title="Abstract 摘要"></a>Abstract 摘要</h2><p>Portable laser range-finders, further referred to as LIDAR, and simultaneous localization and mapping (SLAM) are an efficient method of acquiring as-built floor plans. Generating and visualizing floor plans in real-time helps the operator assess the quality and coverage of capture data. Building a portable capture platform necessitates operating under limited computational resources. We present the approach used in our backpack mapping platform which achieves real-time mapping and loop closure at a 5 cm resolution. To achieve realtime loop closure, we use a branch-and-bound approach for computing scan-to-submap matches as constraints. We provide experimental results and comparisons to other well known approaches which show that, in terms of quality, our approach is competitive with established techniques.</p>
<p>LIDAR SLAM是获取平面地图的有效方法。 实时生成和可视化楼层平面图有助于评估捕获数据的质量和覆盖范围。 构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和＂闭环＂。 为了实现实时＂闭环＂，我们使用branch-and-bound将扫描到Submap匹配计算为约束。 我们提供实验结果并与其他众所周知的方法进行比较，这些方法表明，在质量方面，我们的方法与已有技术相比具有竞争力。</p>
<h2 id="I-INTRODUCTION-简介"><a href="#I-INTRODUCTION-简介" class="headerlink" title="I. INTRODUCTION 简介"></a>I. INTRODUCTION 简介</h2><p>As-built floor plans are useful for a variety of applications.<br>Manual surveys to collect this data for building management tasks typically combine computed-aided design (CAD) with laser tape measures.<br>These methods are slow and, by employing human preconceptions of buildings as collections of straight lines, do not always accurately describe the true nature of the space.<br>Using SLAM, it is possible to swiftly and accurately survey buildings of sizes and complexities that would take orders of magnitude longer to survey manually.<br>Applying SLAM in this field is not a new idea and is not the focus of this paper.<br>Instead, the contribution of this paper is a novel method for reducing the computational requirements of computing <code>loop closure constraints</code> from laser range data.<br>This technique has enabled us to map very large floors, tens-of-thousands of square meters, while providing the operator fully optimized results in real-time.</p>
<p>竣工平面图适用于各种应用。<br>用于收集建筑物管理任务的数据的人工调查通常将计算机辅助设计（CAD）与激光卷尺相结合。<br>这些方法很慢，并且通过将人类对建筑物的偏见视为直线的集合，并不总是准确地描述空间的真实性质。<br>使用SLAM，可以快速准确地调查大小和复杂度的建筑物，这些建筑物需要花费更大的数量级才能手动调查。<br>在这个领域应用SLAM并不是一个新想法，也不是本文的重点。<br>相反，本文的贡献是一种新的方法，用于降低计算激光范围数据的闭环约束的计算要求。<br>这项技术使我们能够绘制数十万平方米的非常大的楼层，同时为操作员提供实时全面优化的结果。</p>
<h2 id="II-RELATED-WORK-相关工作"><a href="#II-RELATED-WORK-相关工作" class="headerlink" title="II. RELATED WORK 相关工作"></a>II. RELATED WORK 相关工作</h2><p><code>Scan-to-scan matching</code> is frequently used to compute relative pose changes in <code>laser-based</code> SLAM approaches, for example [1]–[4].<br>On its own, however, <code>scan-to-scan matching</code> quickly accumulates error.<br><code>Scan-to-map matching</code> helps limit this accumulation of error. One such approach, which uses Gauss-Newton to find local optima on a linearly interpolated map, is [5].<br>In the presence of good initial estimates for the pose, provided in this case by using a sufficiently high data rate LIDAR, locally optimized <code>scan-to-map matching</code> is efficient and robust.<br>On unstable platforms, the laser fan is projected onto the horizontal plane using an inertial measurement unit (IMU) to estimate the orientation of gravity.<br><code>Pixel-accurate</code>scan matching<code>` approaches, such as [1], further reduce local error accumulation.
Although computationally more expensive, this approach is also useful for</code>loop closure detection<code>.
Some methods focus on *improving on* the computational cost by matching on</code>extracted features<code>from the laser scans [4].
Other approaches (for</code>loop closure detection<code>) include</code>histogram-based matching<code>[6],</code>feature detection<code>in scan data, and using</code>machine learning<code>[7].
Two common approaches for</code>addressing the remaining local error accumulation<code>are</code>particle filter<code>and</code>graph-based<code>SLAM [2], [8].</code>Particle filters<code>must maintain a representation of the full system state in each particle.
For</code>grid-based SLAM<code>, this quickly becomes resource intensive as maps become large; e.g. one of our test cases is 22,000 m2 collected over a 3 km trajectory.
Smaller dimensional feature representations, such as [9], which do not require a grid map for each particle, may be used to reduce resource requirements.
When an up-todate grid map is required, [10] suggests computing submaps, which are updated only when necessary, such that the final map is the rasterization of all submaps.</code>Graph-based<code>approaches work over a collection of nodes representing poses and features.
Edges in the graph are constraints generated from observations.
Various optimization methods may be used to minimize the error introduced by all constraints, e.g. [11], [12].
Such a system for outdoor SLAM that uses a graph-based approach, local</code>scan-to-scan` matching, and matching of overlapping local maps based on histograms of submap features is described in [13].</p>
<p><code>Scan-to-scan matching</code>经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 然而，就其本身而言，<code>Scan-to-scan matching</code>很快就会累积误差。</p>
<p><code>Scan-to-map matching</code>有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。<br>在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的<code>Scan-to-map matching</code>是有效且稳健的。<br>在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。</p>
<p><code>pixel-accurate scan matching</code>方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于<code>闭环检测</code>也很有用。<br>一些方法着重于通过匹配激光扫描的<code>提取特征</code>来改善计算成本[4]。其他方法（用于<code>闭环检测</code>）包括<code>基于直方图的匹配</code>[6]，扫描数据中的<code>特征检测</code>，以及使用<code>机器学习</code>[7]。</p>
<p><code>解决累积局部误差</code>的两种常用方法是<code>粒子滤波器</code>和<code>基于图形</code>的SLAM [2]，[8]。</p>
<p><code>粒子滤波器</code>必须保持每个粒子中完整系统状态的表示。 对于<code>基于网格的SLAM</code>，随着地图变大，这很快变得资源密集;例如我们的一个测试案例是在3公里的轨道上收集了22,000平方米。 较小的维度特征表示，例如[9]，其不需要每个粒子的网格图，可用于减少资源需求。 当需要最新的网格图时，[10]建议计算Submap，仅在必要时更新，以便最终的图是所有Submap的光栅化。</p>
<p><code>基于图形</code>的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。<br>在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部<code>scan-to-scan</code>匹配，以及基于Submap特征的直方图的重叠局部图的匹配。</p>
<h2 id="III-SYSTEM-OVERVIEW-系统概述"><a href="#III-SYSTEM-OVERVIEW-系统概述" class="headerlink" title="III. SYSTEM OVERVIEW 系统概述"></a>III. SYSTEM OVERVIEW 系统概述</h2><p><code>Google’s Cartographer</code> provides a real-time solution for indoor mapping in the form of a sensor equipped backpack that generates 2D grid maps with a r = 5 cm resolution.<br>The operator of the system can see the map being created while walking through a building.<br><code>Laser scans</code> are inserted into a submap at the best <code>estimated position</code>, which is assumed to be sufficiently accurate for short periods of time.<br><code>Scan matching</code> happens against a recent <code>submap</code>, so it only depends on recent scans, and the error of <code>pose estimates</code> in the world frame accumulates.<br>To achieve good performance with modest hardware requirements, our SLAM approach does not employ a <code>particle filter</code>.<br>To cope with the accumulation of error, we <code>regularly</code> run a <code>pose optimization</code>.<br>When a submap is finished, that is no new scans will be inserted into it anymore, <code>it takes part in</code>scan matching<code>for loop closure</code>.<br>All finished submaps and scans are automatically considered for loop closure.<br>If they are <code>close enough</code> based on current <code>pose estimates</code>, a <code>scan matcher</code> tries to find the scan in the submap.<br>If a sufficiently good match is found in a search window around the currently <code>estimated pose</code>, it is added as a <code>loop closing constraint</code> to the <code>optimization problem</code>.<br>By completing the optimization every few seconds, the experience of an operator is that <code>loops are closed immediately</code> when <code>a location is revisited</code>.<br>This leads to the <code>soft real-time constraint</code> that the <code>loop closure</code>scan matching<code>` has to</code>happen quicker<code>than</code>new scans are added<code>, otherwise it falls behind noticeably.
We achieve this by using a</code>branch-and-bound approach<code>and several</code>precomputed grids` per finished submap.</p>
<p>Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 <code>Laser scans</code>被插入到最优估算位置的Submap中，假定在短时间内足够准确。 而<code>Scan match</code>发生在最近的<code>Submap</code>上，因此它只取决于最近的扫描，全局误差会累积。</p>
<p>为了在适度的硬件要求下获得良好的性能，我们的SLAM方法不使用<code>粒子滤波器</code>。<br>cartographer <code>定期</code>运行<code>位姿优化</code>来减少误差积累。<br>当一个Submap完成时，就不会再将新的扫描插入其中，它将参与<code>Scan match</code>以获得<code>闭环</code>。<br>所有已完成的Submap和扫描都会自动考虑进行＂闭环＂。<br>如果它们基于当前的<code>位姿估计</code>足够<code>接近</code>，则<code>Scan match器</code>试图在Submap中找到扫描。<br>如果在当前<code>估计位姿</code>的<code>搜索窗口</code>中找到足够好的匹配，则将其作为<code>闭环约束</code>添加到<code>优化问题</code>。</p>
<p>通过每隔几秒完成一次优化，我们的经验就是当<code>重新访问位置</code>时<code>立即闭环</code>。<br>这导致了<code>软实时约束</code>，即<code>闭环Scan match</code>必须<code>比</code>添加新扫描更快<code>，否则它会明显落后,闭环失败。
我们通过对每个完成的Submap使用</code>branch-and-bound<code>和几个</code>预先计算的网格`来实现这一点。</p>
<h2 id="IV-LOCAL-2D-SLAM-局部2d-slam"><a href="#IV-LOCAL-2D-SLAM-局部2d-slam" class="headerlink" title="IV. LOCAL 2D SLAM 局部2d slam"></a>IV. LOCAL 2D SLAM 局部2d slam</h2><p>Our system combines separate local and global approaches to 2D SLAM.<br>Both approaches optimize the pose, $\xi = (\xi_x, \xi_y, \xi_\delta)$ consisting of a $(x, y)$ translation and a rotation $\xi_\delta$, of LIDAR observations, which are further referred to as <code>scans</code>.<br>On an unstable platform, such as our backpack, an IMU is used to estimate the orientation of gravity for projecting scans from the horizontally mounted LIDAR into the 2D world.<br>In our local approach, each consecutive scan is matched against a small chunk of the world, called a <code>submap M</code>, using a <code>non-linear optimization</code> that aligns the scan with the submap; this process is further referred to as <code>scan matching</code>.<br><code>Scan matching</code> accumulates error over time that is later removed by our global approach, which is described in Section V .</p>
<p>我们的系统将单独的局部和全局方法结合到2D SLAM中。<br>两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为<code>扫描</code>。<br>在不稳定的平面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。<br>在我们的局部方法中，每个连续扫描与世界的一小块相匹配，称为<code>Submap</code>，使用<code>非线性优化</code>将扫描与Submap对齐; 该过程进一步称为<code>Scan match</code>。<br><code>Scan match</code>随着时间累积误差，后来我们的全局方法将其去除，如第五节所述。</p>
<h3 id="A-Scans"><a href="#A-Scans" class="headerlink" title="A. Scans"></a>A. Scans</h3><p>Submap construction is the iterative process of repeatedly aligning <code>scan</code> and <code>submap coordinate frames</code>, further referred to as <code>frames</code>.<br>With the origin of the scan at $0 \in \Bbb R^2$ , we now write the information about the scan points as $H = \lbrace h_k\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$ .<br>The pose $\xi$ of the scan frame in the submap frame is represented as the transformation $T_\xi$, which rigidly transforms scan points from the scan frame into the submap frame, defined as</p>
<script type="math/tex; mode=display">
T_\xi = 
\underbrace{
\left(
    \begin {matrix}
        cos\xi_\delta & -sin\xi_\delta \\
        sin\xi_\delta & sin\xi_\delta
    \end{matrix} 
\right)}_{R_\xi}
p +
\underbrace{
\left(\begin {matrix} 
    \xi_x \\
    \xi_y
\end{matrix} \right)}_{t_\xi}.
\tag1</script><h3 id="B-Submaps"><a href="#B-Submaps" class="headerlink" title="B. Submaps"></a>B. Submaps</h3><p>A few consecutive scans are used to build a submap.<br>These submaps take the form of probability grids $M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$ which map from discrete grid points at a given resolution <code>r</code>, for example 5 cm, to values.<br>These values can be thought of as the probability that a grid point is obstructed.<br>For each grid point, we define the corresponding <code>pixel</code> to consist of all points that are closest to that grid point.<br>Whenever a scan is to be inserted into the probability grid, a set of grid points for hits and a disjoint set for misses are computed.<br>For every hit, we insert the closest grid point into the hit set.<br>For every miss, we insert the grid point associated with each pixel that intersects one of the rays between the scan origin and each scan point, excluding grid points which are already in the hit set.<br>Every formerly unobserved grid point is assigned a probability $p_{hit}$ or $p_{miss}$ if it is in one of these sets.<br>If the grid point x has already been n observed, we update the odds for hits and misses as</p>
<script type="math/tex; mode=display">
odds(p) = \frac{p}{1-p}, \tag1</script><script type="math/tex; mode=display">
M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1</script><p>and equivalently for misses</p>
<p>等同于未命中</p>
<p><img src="/home/syue/github/cartographer-notes/docs/asset/carto_submap.png" alt="image"></p>
<h3 id="C-Ceres-scan-matching"><a href="#C-Ceres-scan-matching" class="headerlink" title="C. Ceres scan matching"></a>C. Ceres <code>scan matching</code></h3><p>Prior to inserting a scan into a submap, the scan pose $\xi$ is optimized, relative to the current local submap,(using a Ceresbased [14] <code>scan matcher</code>). The <code>scan matcher</code> is responsible for finding a scan pose that <code>maximizes the probabilities</code> at the scan points in the submap. We cast this as a <code>nonlinear least squares problem</code></p>
<p>在将扫描插入Submap之前，扫描位姿<code>ξ</code>相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到<code>最大概率</code>的扫描位姿。 我们将其视为<code>非线性最小二乘问题</code></p>
<script type="math/tex; mode=display">
 \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2</script><p>where $T\xi$ transforms $h_k$ from the scan frame to the submap frame according to the scan pose.<br>The function $M_{smooth} : \Bbb R^2 → \Bbb R$ is a smooth version of the probability values in the local submap.<br>We use bicubic interpolation.<br>As a result, values outside the interval $[0, 1]$ can occur but are considered harmless.</p>
<p>其中$T\xi$根据扫描位姿将$h_k$从扫描帧变换到Submap帧。<br>函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。<br>我们使用双三次插值。<br>结果，可以发生区间$[0, 1]$之外的值，但是被认为是无害的。</p>
<p>Mathematical optimization of this smooth function usually gives better precision than the resolution of the grid.<br>Since this is a local optimization, good initial estimates are required.<br>An IMU capable of measuring angular velocities can be used to estimate the rotational component $\theta$ of the pos between scan matches.<br>A higher frequency of scan matches or a <code>pixel-accurate</code>scan matching`` approach, although more computationally intensive, can be used in the absence of an IMU.</p>
<p>这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。<br>由于这是局部优化，因此需要良好的初始估计。<br>能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。<br>虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。</p>
<h2 id="V-CLOSING-LOOPS-闭环"><a href="#V-CLOSING-LOOPS-闭环" class="headerlink" title="V. CLOSING LOOPS 闭环"></a>V. CLOSING LOOPS 闭环</h2><p>As scans are only matched against a submap containing a few recent scans, the approach described above slowly accumulates error.<br>For only a few dozen consecutive scans, the accumulated error is small.<br>Larger spaces are handled by creating many small submaps.<br>Our approach, optimizing the poses of all scans and submaps, follows <code>Sparse Pose Adjustment</code> [2].<br>The relative poses where scans are inserted are stored in memory for use in the loop closing optimization.<br>In addition to these relative poses, all other pairs consisting of a scan and a submap are considered for loop closing once the submap no longer changes.<br>A <code>scan matcher</code> is run in the background and if a good match is found, the corresponding relative pose is added to the optimization problem</p>
<p>由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。<br>对于仅几十次连续扫描，累积误差很小。<br>通过创建许多小Submap来处理更大的空间。<br>我们的方法，优化所有扫描和Submap的位姿，遵循”稀疏位姿调整”[2]。<br>插入扫描的相对位姿存储在存储器中，以用于＂闭环＂优化。<br>除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由扫描和Submap组成的对都被认为是＂闭环＂。<br>Scan match器在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中</p>
<h3 id="A-Optimization-problem"><a href="#A-Optimization-problem" class="headerlink" title="A. Optimization problem"></a>A. Optimization problem</h3><p><code>Loop closure</code> optimization, like <code>scan matching</code>, is also formulated as <code>a nonlinear least squares problem</code> which allows easily adding residuals to take additional data into account.<br>Once every few seconds, we use Ceres [14] to compute a solution to</p>
<p>＂闭环＂优化，如<code>Scan match</code>，也被称为<code>非线性最小二乘问题</code>，它允许轻松添加残差以考虑其他数据。<br>每隔几秒钟，我们使用Ceres [14]来计算解决方案</p>
<script type="math/tex; mode=display">
\underset{\Xi^m,\Xi^n}{argmin} \frac{1}{2}\sum_{ij}\rho(E^2(\xi _i^m,\xi _j^s;\sigma_{ij},\xi_{ij}))\tag{SPA}</script><p>where the submap poses $\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$ and the scan poses $\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$ in the world are optimized given some constraints.<br>These constraints take the form of relative poses $\xi_{ij}$ and associated covariance matrices $\Sigma_ij$ .<br>For a pair of submap i and scan j, the pose ξij describes where in the submap coordinate frame the scan was matched.<br>The covariance matrices Σij can be evaluated, for example, following the approach in [15], or locally using the covariance estimation feature of Ceres [14] with (CS).<br>The residual E for such a constraint is computed by</p>
<p>在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。<br>这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。<br>对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。<br>协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。<br>这种约束的残差E由下式计算</p>
<script type="math/tex; mode=display">
E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4</script><script type="math/tex; mode=display">
e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - 
\left( 
    \begin{matrix} 
    R_{\xi_i^m}^{-1}(t_{\xi_i^m}-t_{\xi_j^s}) \\
    \xi_{ij} - \xi_{j;\theta}^s
    \end{matrix}
\right).\tag5</script><p>A loss function $\rho$, for example <code>Huber loss</code>, is used to reduce the influence of outliers which can appear in (SPA) when <code>scan matching</code> adds incorrect constraints to the optimization problem.<br>For example, this may happen in locally symmetric environments, such as office cubicles.<br>Alternative approaches to outliers include [16]. </p>
<p>损失函数$\rho$，例如<code>Huber loss</code>，用于减少当<code>Scan match</code>为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。<br>例如，这可能发生在局部对称环境中，例如办公室隔间。<br>异常值的替代方法包括[16]。</p>
<h3 id="B-Branch-and-bound-scan-match"><a href="#B-Branch-and-bound-scan-match" class="headerlink" title="B. Branch-and-bound scan match"></a>B. Branch-and-bound scan match</h3><p>We are interested in the optimal, <code>pixel-accurate match</code></p>
<p>我们对最佳的<code>像素精确匹配</code>感兴趣</p>
<script type="math/tex; mode=display">
\xi^* = \underset{\xi\in\omega}{argmax}\sum_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}</script><p>where $\omega$ is the search window and $M_{nearest}$ is M extended to all of $\Bbb R^2$ by rounding its arguments to the nearest grid point first, that is extending the value of a grid points to the corresponding pixel.<br>The quality of the match can be improved further using (CS).</p>
<p>其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。</p>
<p>Efficiency is improved by carefully choosing step sizes.<br>We choose the angular step size $\xi_\theta$ so that scan points at the maximum range $d_{max}$ do not move more than $r$, the width of one pixel.<br>Using the law of cosines, we derive </p>
<p>通过仔细选择步长来提高效率。<br>我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。<br>我们推导出使用余弦定律</p>
<script type="math/tex; mode=display">
d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\</script><script type="math/tex; mode=display">
\xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7</script><p>We compute an integral number of steps covering given linear and angular search window sizes, e.g., $W_x = W_y = 7m$ and $W_\theta = 30\degree$</p>
<p>我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30\degree$</p>
<script type="math/tex; mode=display">
w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W_\theta}{\xi_\theta}\rceil.\tag8</script><p>This leads to a finite set $W$ forming a search window around an estimate $\xi_\theta$ placed in its center,</p>
<p>这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口，</p>
<script type="math/tex; mode=display">
\overline{W} = \{-w_x,...,w_x\} \times \{-w_y,...,w_y\} \times \{-w_\theta,...,w_\theta\}\tag9</script><script type="math/tex; mode=display">
W = \{\xi_0 + (rj_x, rj_y, \xi_\theta j_\theta):(j_x,j_y,j_\theta) \in \overline{W}\}\tag{10}</script><p>A naive algorithm to find $\xi^*$ can easily be formulated, see Algorithm 1, but for the search window sizes we have in mind it would be far too slow . </p>
<p>找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">algo</span><br></pre></td></tr></table></figure></p>
<p>Instead, we use a branch and bound approach to efficiently compute $\xi^*$ over larger search windows.<br>See Algorithm 2 for the generic approach.<br>This approach was first suggested in the context of mixed integer linear programs [17].<br>Literature on the topic is extensive; see [18] for a short overview.<br>The main idea is to represent subsets of possibilities as nodes in a tree where the root node represents all possible solutions, $W$ in our case.<br>The children of each node form a partition of their parent, so that they together represent the same set of possibilities.<br>The leaf nodes are singletons; each represents a single feasible solution.<br>Note that the algorithm is exact.<br>It provides the same solution as the naive approach as long as the score(c) of inner nodes c is an upper bound on the score of its elements.<br>In that case, whenever a node is bounded, a solution better than the best known solution so far does not exist in this subtree. </p>
<p>相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。<br>有关通用方法，请参见算法2。<br>这种方法最初是在混合整数线性程序的背景下提出的[17]。<br>关于这个主题的文献很广泛; 见[18]简短概述。<br>主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。<br>每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。<br>叶节点是单体; 每个代表一个可行的解决方案。<br>请注意，算法是准确的。<br>只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。<br>在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。</p>
<p>To arrive at a concrete algorithm, we have to decide on the method of node selection, branching, and computation of upper bounds.</p>
<p>为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。</p>
<h4 id="1-Node-selection"><a href="#1-Node-selection" class="headerlink" title="1) Node selection:"></a>1) Node selection:</h4><p>Our algorithm uses depth-first search (DFS) as the default choice in the absence of a better alternative: The efficiency of the algorithm depends on a large part of the tree being pruned.<br>This depends on two things: a good upper bound, and a good current solution.<br>The latter part is helped by DFS, which quickly evaluates many leaf nodes.<br>Since we do not want to add poor matches as loop closing constraints, we also introduce a score threshold below which we are not interested in the optimal solution.<br>Since in practice the threshold will not often be surpassed, this reduces the importance of the node selection or finding an initial heuristic solution.<br>Regarding the order in which the children are visited during the DFS, we compute the upper bound on the score for each child, visiting the most promising child node with the largest bound first.<br>This method is Algorithm 3. </p>
<p>1）节点选择：</p>
<p>在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。<br>这取决于两件事：良好的上限和良好的当前解决方案。<br>后一部分由DFS帮助，它可以快速评估许多叶节点。<br>由于我们不希望将不良匹配作为＂闭环＂约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。<br>由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。<br>关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。<br>算法3是这种方法。</p>
<h4 id="2-Branching-rule"><a href="#2-Branching-rule" class="headerlink" title="2) Branching rule:"></a>2) Branching rule:</h4><p> Each node in the tree is described by a tuple of integers $c = (c_x, c_y, c_θ, c_h) \in \Bbb Z^4$.<br>Nodes at height ch combine up to $2^{ch}\times2^{ch}$ possible translations but represent a specific rotation: </p>
<p>2）分支规则：</p>
<p>树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。<br>高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换：</p>
<script type="math/tex; mode=display">
\overline {\overline{W}} = (\{j_x,j_y\} \in \Bbb{Z}^2:\\
        \left.
        \begin{array}{l}
        c_x \leq j_x < c_x + 2^{ch}\\
        c_x \leq j_x < c_x + 2^{ch}
        \end{array}
        \right\}
        \times \{c_\theta\},\tag11</script><script type="math/tex; mode=display">
\overline{W}_c = \overline{\overline{W}} \cap \overline{W}\tag{12}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">algo2</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">algo3</span><br></pre></td></tr></table></figure>
<p>Leaf nodes have height ch = 0, and correspond to feasible solutions $W\ni \xi_c=\xi_0+(rc_x,rc_y,\xi_\theta c_\theta)$.</p>
<p>叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。</p>
<p>In our formulation of Algorithm 3, the root node, encompassing all feasible solutions, does not explicitly appear and branches into a set of initial nodes $C_0$ at a fixed height $h_0$ covering the search window</p>
<p>在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口</p>
<script type="math/tex; mode=display">
\overline{W}_{0,x} =  \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\
\overline{W}_{0,x} =  \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\
\overline{W}_{0,x} =  \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\
C_0 = \overline{W}_{0,x} \times \overline{W}_{0,y} \times \overline{W}_{0,\theta} \times \{h_0\} \tag{13}</script><p>At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$<br>在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$</p>
<script type="math/tex; mode=display">
C_c = ((\{c_x,c_x + 2^{c_h-1}\} \times {c_y, c_y + 2^{c_h-1} \times c_\theta}) \cap \overline{W}) \times \{c_h-1\}\tag{14}</script><h4 id="3-Computing-upper-bounds"><a href="#3-Computing-upper-bounds" class="headerlink" title="3) Computing upper bounds:"></a>3) Computing upper bounds:</h4><p>The remaining part of the branch and bound approach is an efficient way to compute upper bounds at inner nodes, both in terms of computational effort and in the quality of the bound.<br>We use<br>3）计算上界：</p>
<p>分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。<br>我们用</p>
<script type="math/tex; mode=display">
score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\
\geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M_{nearest}(T\xi_{j}h_{k})\\
\underset{j\in \overline{W_c}}{max}\sum_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k})\tag{15}</script><p>To be able to compute the maximum efficiently, we use precomputed grids $M_{precomp}^{ch}$.<br>Precomputing one grid per possible height $c_h$ allows us to compute the score with effor linear in the number of scan points.<br>Note that, to be able to do this, we also compute the maximum over $\overline{\overline{W_c}}$ which can be larger than $\overline{W_c}$near the boundary of our search space.</p>
<p>为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。<br>每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。<br>请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。</p>
<script type="math/tex; mode=display">
score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16}</script><script type="math/tex; mode=display">
M_{precomp}^{ch}(x,y) =  
    \underset
    {\begin{matrix}
        x^, \in [x,x+r(2^h-1)] \\
        y^, \in [y,y+r(2^h-1)]
    \end{matrix}}
    {max}
M_{nearest}(x^, , y^,) \tag{17}</script><p>with $\xi_c$ as before for the leaf nodes.<br>Note that Mh precomp has the same pixel structure as $M_{nearest}$, but in each pixel storing the maximum of the values of the $2^h \times 2^h$ box of pixels beginning there.<br>An example of such precomputed grids is given in Figure 3.<br>与叶节点一样使用$\xi_c$。<br>请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。<br>图3给出了这种预先计算的网格的一个例子。</p>
<p>To keep the computational effort for constructing the precomputed grids low, we wait until a probability grid will receive no further updates.<br>Then we compute a collection of precomputed grids, and start matching against it. </p>
<p>为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。<br>然后我们计算一组预先计算的网格，并开始匹配它。</p>
<p>For each precomputed grid, we compute the maximum of a $2^h$ pixel wide row starting at each pixel.<br>Using this intermediate result, the next precomputed grid is then constructed.</p>
<p>对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。<br>使用该中间结果，然后构造下一个预先计算的网格。</p>
<p>The maximum of a changing collection of values can be kept up-to-date in amortized $O(1)$ if values are removed in the order in which they have been added.<br>Successive maxima are kept in a deque that can be defined recursively as containing the maximum of all values currently in the collection followed by the list of successive maxima of all values after the first occurrence of the maximum.<br>For an empty collection of values, this list is empty.<br>Using this approach, the precomputed grids can be computed in $O(n)$ where n is the number of pixels in each precomputed grids. </p>
<p>如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。<br>连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。<br>对于空的值集合，此列表为空。<br>使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。</p>
<p>An alternative way to compute upper bounds is to compute lower resolution probability grids, successively halving the resolution, see [1].<br>Since the additional memory consumption of our approach is acceptable, we prefer it over using lower resolution probability grids which lead to worse bounds than (15) and thus negatively impact performance.</p>
<p>计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。<br>由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。</p>
<h2 id="VI-EXPERIMENTAL-RESULTS-实验结果"><a href="#VI-EXPERIMENTAL-RESULTS-实验结果" class="headerlink" title="VI. EXPERIMENTAL RESULTS 实验结果"></a>VI. EXPERIMENTAL RESULTS 实验结果</h2><p>In this section, we present some results of our SLAM algorithm computed from recorded sensor data using the same online algorithms that are used interactively on the backpack.<br>First, we show results using data collected by the sensors of our Cartographer backpack in the Deutsches Museum in Munich.<br>Second, we demonstrate that our algorithms work well with inexpensive hardware by using data collected from a <code>robotic vacuum cleaner</code> sensor.<br>Lastly, we show results using the <code>Radish data set</code> [19] and compare ourselves to published results.</p>
<p>在本节中，我们使用在背包上交互使用的相同在线算法，从记录的传感器数据中计算出我们的SLAM算法的一些结果。<br>首先，我们使用慕尼黑德意志博物馆的Cartographer背包传感器收集的数据显示结果。<br>其次，我们通过使用从<code>机器人真空吸尘器</code>传感器收集的数据证明我们的算法可以很好地与廉价的硬件配合使用。<br>最后，我们使用<code>萝卜数据集</code>[19]显示结果，并将自己与已发布的结果进行比较。</p>
<h3 id="A-Real-World-Experiment-Deutsches-Museum"><a href="#A-Real-World-Experiment-Deutsches-Museum" class="headerlink" title="A. Real-World Experiment: Deutsches Museum"></a>A. Real-World Experiment: Deutsches Museum</h3><p>Using data collected at the Deutsches Museum spanning 1,913 s of sensor data or 2,253 m (according to the computed solution), we computed the map shown in Figure 4.<br>On a workstation with an Intel Xeon E5-1650 at 3.2 GHz, our SLAM algorithm uses 1,018 s CPU time, using up to 2.2 GB of memory and up to 4 background threads for loop closure <code>scan matching</code>.<br>It finishes after 360 s wall clock time, meaning it achieved 5.3 times real-time performance.<br>The generated graph for the loop closure optimization consists of 11,456 nodes and 35,300 edges.<br>The optimization problem (SPA) is run every time a few nodes have been added to the graph.<br>A typical solution takes about 3 iterations, and finishes in about 0.3 s.</p>
<p>使用在德意志博物馆收集的数据，跨越1,913秒的传感器数据或2,253米（根据计算的解决方案），我们计算出如图4所示的地图。<br>在具有3.2 GHz的Intel Xeon E5-1650的工作站上，我们的SLAM算法使用1,018秒的CPU时间，使用高达2.2 GB的内存和最多4个后台线程进行闭环Scan match。<br>它在360秒的挂钟时间后完成，这意味着它实现了5.3倍的实时性能。<br>生成的＂闭环＂优化图由11,456个节点和35,300个边组成。<br>每次向图表添加几个节点时都会运行优化问题（SPA）。<br>典型的解决方案需要大约3次迭代，并在大约0.3秒内完成。</p>
<h3 id="B-Real-World-Experiment-Neato’s-Revo-LDS"><a href="#B-Real-World-Experiment-Neato’s-Revo-LDS" class="headerlink" title="B. Real-World Experiment: Neato’s Revo LDS"></a>B. Real-World Experiment: Neato’s Revo LDS</h3><p>Neato Robotics uses a laser distance sensor (LDS) called Revo LDS [20] in their vacuum cleaners which costs under $ 30.<br>We captured data by pushing around the vacuum cleaner on a trolley while taking scans at approximately 2 Hz over its debug connection.<br>Figure 5 shows the resulting 5 cm resolution floor plan.<br>To evaluate the quality of the floor plan, we compare laser tape measurements for 5 straight lines to the pixel distance in the resulting map as computed by a drawing tool.<br>The results are presented in Table I, all values are in meters.<br>The values are roughly in the expected order of magnitude of one pixel at each end of the line.</p>
<p>Neato Robotics在其真空吸尘器中使用名为Revo LDS [20]的激光距离传感器（LDS），售价低于30美元。<br>我们通过推动手推车上的真空吸尘器捕获数据，同时通过其调试连接以大约2 Hz的速度进行扫描。<br>图5显示了5厘米分辨率的平面图。<br>为了评估平面图的质量，我们将5条直线的激光带测量结果与绘图工具计算得到的地图中的像素距离进行比较。<br>结果如表I所示，所有数值均以米为单位。<br>这些值大致在线的每一端的一个像素的预期数量级。</p>
<p>We compare our approach to others using the benchmark measure suggested in [21], which compares the error in relative pose changes to manually curated <code>ground truth</code> relations.<br>Table II shows the results computed by our Cartographer SLAM algorithm.<br>For comparison, we quote results for Graph Mapping (GM) from [21].<br>Additionally, we quote more recently published results from [9] in Table III.<br>All errors are given in meters and degrees, either absolute or squared, together with their standard deviation.<br>Each public data set was collected with a unique sensor configuration that differs from our Cartographer backpack.<br>Therefore, various algorithmic parameters needed to be adapted to produce reasonable results.<br>In our experience, tuning Cartographer is only required to match the algorithm to the sensor configuration and not to the specific surroundings.</p>
<p>我们使用[21]中建议的基准测量法将我们的方法与其他方法进行比较，后者将相对姿态变化的误差与手动策划的地面实况关系进行比较。<br>表II显示了我们的制图师SLAM算法计算的结果。<br>为了比较，我们引用[21]中的图形构图（GM）的结果。<br>此外，我们引用表III中最近公布的[9]结果。<br>所有误差均以米和度给出，绝对值或平方值，以及它们的标准偏差。<br>每个公共数据集都采用独特的传感器配置进行收集，该配置与我们的Cartographer背包不同。<br>因此，需要调整各种算法参数以产生合理的结果。<br>根据我们的经验，调整制图师只需要将算法与传感器配置相匹配，而不是与特定环境相匹配。</p>
<p>Since each public data set has a unique sensor configuration, we cannot be sure that we did not also fit our parameters to the specific locations. The only exception being the Freiburg hospital data set where there are two separate relations files. We tuned our parameters using the local relations but also see good results on the global relations.</p>
<p>由于每个公共数据集都有一个独特的传感器配置，我们无法确定，我们也不适合我们的参数到特定的位置。 唯一的例外是弗莱堡医院数据集，其中有两个独立的关系文件。 我们使用当地关系调整了参数，但也看到了全局关系的良好结果。</p>
<p>The most significant differences between all data sets is the frequency and quality of the laser scans as well as the availability and quality of odometry.<br>所有数据集之间最显着的差异是激光扫描的频率和质量以及测距的可用性和质量。</p>
<p>Despite the relatively outdated sensor hardware used in the public data sets, Cartographer SLAM consistently performs within our expectations, even in the case of <code>MIT CSAIL</code>, where we perform considerably worse than <code>Graph Mapping</code>.<br>For the Intel data set, we outperform <code>Graph Mapping</code>, but not <code>Graph FLIRT</code>.<br>For MIT Killian Court we outperform <code>Graph Mapping</code> in all metrics.<br>In all other cases, Cartographer outperforms both <code>Graph Mapping</code> and <code>Graph FLIRT</code> in most but not all metrics<br>尽管公共数据集中使用了相对过时的传感器硬件，但Cartographer SLAM始终如一地符合我们的预期，即使在<code>MIT CSAIL</code>的情况下，我们的表现也比<code>图谱构图</code>差得多。<br>对于英特尔数据集，我们优于<code>图形构图</code>，但不是<code>图形FLIRT</code>。<br>对于MIT Killian Court，我们在所有指标中都超越了<code>图形构图</code>。<br>在所有其他情况下，Cartographer在大多数但不是所有指标中都优于<code>图形构图</code>和<code>图形FLIRT</code></p>
<p>Since we add <code>loop closure constraints</code> between submaps and scans, the data sets contain no <code>ground truth</code> for them.<br>It is also difficult to compare numbers with other approaches based on <code>scan-to-scan</code>.<br>Table IV shows the number of <code>loop closure constraints</code> added for each test case (true and false positives), as well as the precision, that is the fraction of true positives.<br>We determine the set of true positive constraints to be the subset of all <code>loop closure constraints</code> which are not violated by more than 20 cm or 1 ◦ when we compute (SPA).<br>We see that while our <code>scan-to-submap matching</code> procedure produces false positives which have to be handled in the optimization (SPA), it manages to provide a sufficient number of <code>loop closure constraints</code> in all test cases.<br>Our use of the Huber loss in (SPA) is one of the factors that renders loop closure robust to outliers.<br>In the Freiburg hospital case, the choice of a low resolution and a low minimum score for the <code>loop closure detection</code> produces a comparatively high rate of false positives.<br>The precision can be improved by raising the minimum score for <code>loop closure detection</code>, but this decreases the solution quality in some dimensions according to <code>ground truth</code>.<br>The authors believe that the <code>ground truth</code> remains the better benchmark of final map quality.</p>
<p>由于我们在Submap和扫描之间添加了<code>＂闭环＂约束</code>，因此数据集中不包含<code>基础事实</code>。<br>将数字与基于<code>scan-to-scan</code>的其他方法进行比较也很困难。<br>表IV显示了为每个测试用例添加的<code>＂闭环＂约束</code>的数量（真和假阳性），以及精度，即真阳性的分数。<br>我们确定真正的正约束集合是所有<code>＂闭环＂约束</code>的子集，当我们计算（SPA）时，它们不会超过20厘米或1秒。<br>我们看到，虽然我们的扫描到Submap匹配过程产生必须在优化（SPA）中处理的误报，但它设法在所有测试用例中提供足够数量的<code>＂闭环＂约束</code>。<br>我们在（SPA）中使用Huber损失是使＂闭环＂对异常值具有鲁棒性的因素之一。<br>在弗莱堡医院案例中，对闭环检测的低分辨率和低最低分数的选择产生相对较高的误报率。<br>通过提高闭环检测的最小分数可以提高精度，但是根据<code>基础事实</code>，这会降低某些维度的解决方案质量。<br>作者认为，<code>基础事实</code>仍然是最终地图质量的更好基准。</p>
<p>The parameters of Cartographer’s SLAM were not tuned for CPU performance.<br>We still provide the wall clock times in Table V which were again measured on a workstation with an Intel Xeon E5-1650 at 3.2 GHz.<br>We provide the duration of the sensor data for comparison.</p>
<p>Cartographer的SLAM参数没有针对CPU性能进行调整。<br>我们仍然提供表V中的挂钟时间，这些时间再次在具有3.2 GHz的Intel Xeon E5-1650的工作站上测量。<br>我们提供传感器数据的持续时间以供比较。</p>
<h2 id="VII-CONCLUSIONS-结论"><a href="#VII-CONCLUSIONS-结论" class="headerlink" title="VII. CONCLUSIONS 结论"></a>VII. CONCLUSIONS 结论</h2><p>In this paper, we presented and experimentally validated a 2D SLAM system that combines <code>scan-to-submap matching</code> with <code>loop closure detection</code> and <code>graph optimization</code>.<br>Individual submap trajectories are created using our local, grid-based SLAM approach.<br>In the background, all scans are matched to nearby submaps using <code>pixel-accurate</code>scan matching<code>` to create</code>loop closure constraints`.<br>The constraint graph of submap and scan poses is periodically optimized in the background.<br>The operator is presented with an upto-date preview of the final map as a GPU-accelerated combination of finished submaps and the current submap.<br>We demonstrated that it is possible to run our algorithms on modest hardware in real-time.</p>
<p>在本文中，我们提出并实验验证了一个2D SLAM系统，该系统将<code>扫描到Submap匹配</code>与<code>＂闭环＂检测</code>和<code>图形优化</code>相结合。<br>使用我们的基于网格的局部SLAM方法创建单个Submap轨迹。<br>在后台，所有扫描都使用<code>像素精确Scan match</code>匹配到附近的Submap，以创建<code>＂闭环＂约束</code>。<br>Submap和扫描位姿的约束图在后台定期优化。<br>向操作员呈现最终地图的最新预览，作为完成的子地图和当前子地图的GPU加速组合。<br>我们证明了可以在适度的硬件上实时运行我们的算法。</p>
<h2 id="ACKNOWLEDGMENTS-致谢"><a href="#ACKNOWLEDGMENTS-致谢" class="headerlink" title="ACKNOWLEDGMENTS 致谢"></a>ACKNOWLEDGMENTS 致谢</h2><p>This research has been validated through experiments in the Deutsches Museum, Munich.<br>The authors thank its administration for supporting our work.<br>Comparisons were done using manually verified relations and results from [21] which uses data from the Robotics Data Set Repository (Radish) [19].<br>Thanks go to Patrick Beeson, Dieter Fox, Dirk Hahnel, Mike Bosse, John Leonard, ¨ Cyrill Stachniss for providing this data.<br>The data for the Freiburg University Hospital was provided by Bastian Steder, Rainer Kummerle, Christian Dornhege, Michael Ruhnke, ¨ Cyrill Stachniss, Giorgio Grisetti, and Alexander Kleiner.</p>
<p>这项研究已通过慕尼黑德意志博物馆的实验得到验证。<br>作者感谢其政府支持我们的工作。<br>使用手动验证的关系和来自[21]的结果进行比较，该结果使用来自机器人数据集库（Radish）[19]的数据。<br>感谢Patrick Beeson，Dieter Fox，Dirk Hahnel，Mike Bosse，John Leonard，Cyrill Stachniss提供这些数据。<br>弗赖堡大学医院的数据由Bastian Steder，Rainer Kummerle，Christian Dornhege，Michael Ruhnke，Cyrill Stachniss，Giorgio Grisetti和Alexander Kleiner提供。</p>
<h2 id="REFERENCES-参考"><a href="#REFERENCES-参考" class="headerlink" title="REFERENCES 参考"></a>REFERENCES 参考</h2><p>[1] E. Olson, <code>M3RSM: Many-to-many multi-resolution</code>scan matching<code>,</code> in Proceedings of the IEEE International Conference on Robotics and Automation (ICRA), June 2015.<br>[2] K. Konolige, G. Grisetti, R. Kummerle, W. Burgard, B. Limketkai, ¨ and R. Vincent, <code>Sparse pose adjustment for 2D mapping,</code> in IROS, Taipei, Taiwan, 10/2010 2010.<br>[3] F. Lu and E. Milios, <code>Globally consistent range scan alignment for environment mapping,</code> Autonomous robots, vol. 4, no. 4, pp. 333– 349, 1997.<br>[4] F. Mart´ın, R. Triebel, L. Moreno, and R. Siegwart, <code>Two different tools for three-dimensional mapping: DE-based</code>scan matching<code>and feature-based loop detection,</code> Robotica, vol. 32, no. 01, pp. 19–41, 2014.<br>[5] S. Kohlbrecher, J. Meyer, O. von Stryk, and U. Klingauf, <code>A flexible and scalable SLAM system with full 3D motion estimation,</code> in Proc. IEEE International Symposium on Safety, Security and Rescue Robotics (SSRR). IEEE, November 2011.<br>[6] M. Himstedt, J. Frost, S. Hellbach, H.-J. Bohme, and E. Maehle, ¨ <code>Large scale place recognition in 2D LIDAR scans using geometrical landmark relations,</code> in Intelligent Robots and Systems (IROS 2014), 2014 IEEE/RSJ International Conference on. IEEE, 2014, pp. 5030– 5035.<br>[7] K. Granstrom, T. B. Sch ¨ on, J. I. Nieto, and F. T. Ramos, <code>Learning to ¨ close loops from range data,</code> The International Journal of Robotics Research, vol. 30, no. 14, pp. 1728–1754, 2011.<br>[8] G. Grisetti, C. Stachniss, and W. Burgard, <code>Improving grid-based SLAM with Rao-Blackwellized particle filters by adaptive proposals and selective resampling,</code> in Robotics and Automation, 2005. ICRA 2005. Proceedings of the 2005 IEEE International Conference on. IEEE, 2005, pp. 2432–2437.<br>[9] G. D. Tipaldi, M. Braun, and K. O. Arras, <code>FLIRT: Interest regions for 2D range data with applications to robot navigation,</code> in Experimental Robotics. Springer, 2014, pp. 695–710.</p>
<p>1875/5000<br>[1] E. Olson，<code>M3RSM：多对多分辨率Scan match</code>，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。<br>[2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，<code>&quot;稀疏位姿调整&quot;2D绘图</code>，在IROS，台湾台北，2010年10月10日。<br>[3] F. Lu和E. Milios，<code>用于环境绘图的全局一致范围扫描对准</code>，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。<br>[4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，<code>两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测</code>，Robotica，vol。 32，不。 01，pp.19-41,2014。<br>[5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，<code>具有完整3D运动估计的灵活且可扩展的SLAM系统</code>，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。<br>[6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，<code>使用几何地标关系的2D LIDAR扫描中的大规模地点识别</code>，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。<br>[7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，<code>学习close闭合范围数据循环</code>，<code>国际机器人研究杂志</code>，第一卷。 30，不。 14，pp.1728-1754,2011。<br>[8] G. Grisetti，C。Stachniss和W. Burgard，<code>通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器</code>，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。<br>[9] G. D. Tipaldi，M。Braun和K. O. Arras，<code>FLIRT：2D范围数据的兴趣区域，应用于机器人导航</code>，在实验机器人中。 Springer，2014年，第695-710页。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    ShaoYue Lin
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://lsy563193.github.io/cartographer_source/real-time-loop-closure-in-2d-lidar-slam-en/" title="">http://lsy563193.github.io/cartographer_source/real-time-loop-closure-in-2d-lidar-slam-en/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/cartographer_source/local_slam/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/deep-learning-AndrewNgDeepLearningNotes/" rel="prev" title="吴恩达《深度学习》系列课程个人笔记">
                吴恩达《深度学习》系列课程个人笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars0.githubusercontent.com/u/4884007?s=400&u=af3c3a113957bd20c7f2b0102773570000f7b48a&v=4"
                alt="ShaoYue Lin" />
            
              <p class="site-author-name" itemprop="name">ShaoYue Lin</p>
              <p class="site-description motion-element" itemprop="description">持续学习</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">22</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/lsy563193" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://youtube.com/" target="_blank" title="YouTube">
                      
                        <i class="fa fa-fw fa-youtube"></i>YouTube</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Links
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://hexo.io/zh-cn/" title="Hexo" target="_blank">Hexo</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com/" title="nexT" target="_blank">nexT</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract-摘要"><span class="nav-number">1.</span> <span class="nav-text">Abstract 摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-INTRODUCTION-简介"><span class="nav-number">2.</span> <span class="nav-text">I. INTRODUCTION 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#II-RELATED-WORK-相关工作"><span class="nav-number">3.</span> <span class="nav-text">II. RELATED WORK 相关工作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#III-SYSTEM-OVERVIEW-系统概述"><span class="nav-number">4.</span> <span class="nav-text">III. SYSTEM OVERVIEW 系统概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IV-LOCAL-2D-SLAM-局部2d-slam"><span class="nav-number">5.</span> <span class="nav-text">IV. LOCAL 2D SLAM 局部2d slam</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Scans"><span class="nav-number">5.1.</span> <span class="nav-text">A. Scans</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Submaps"><span class="nav-number">5.2.</span> <span class="nav-text">B. Submaps</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Ceres-scan-matching"><span class="nav-number">5.3.</span> <span class="nav-text">C. Ceres scan matching</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#V-CLOSING-LOOPS-闭环"><span class="nav-number">6.</span> <span class="nav-text">V. CLOSING LOOPS 闭环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Optimization-problem"><span class="nav-number">6.1.</span> <span class="nav-text">A. Optimization problem</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Branch-and-bound-scan-match"><span class="nav-number">6.2.</span> <span class="nav-text">B. Branch-and-bound scan match</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Node-selection"><span class="nav-number">6.2.1.</span> <span class="nav-text">1) Node selection:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Branching-rule"><span class="nav-number">6.2.2.</span> <span class="nav-text">2) Branching rule:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Computing-upper-bounds"><span class="nav-number">6.2.3.</span> <span class="nav-text">3) Computing upper bounds:</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VI-EXPERIMENTAL-RESULTS-实验结果"><span class="nav-number">7.</span> <span class="nav-text">VI. EXPERIMENTAL RESULTS 实验结果</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Real-World-Experiment-Deutsches-Museum"><span class="nav-number">7.1.</span> <span class="nav-text">A. Real-World Experiment: Deutsches Museum</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#B-Real-World-Experiment-Neato’s-Revo-LDS"><span class="nav-number">7.2.</span> <span class="nav-text">B. Real-World Experiment: Neato’s Revo LDS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VII-CONCLUSIONS-结论"><span class="nav-number">8.</span> <span class="nav-text">VII. CONCLUSIONS 结论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ACKNOWLEDGMENTS-致谢"><span class="nav-number">9.</span> <span class="nav-text">ACKNOWLEDGMENTS 致谢</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REFERENCES-参考"><span class="nav-number">10.</span> <span class="nav-text">REFERENCES 参考</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShaoYue Lin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  


  

  

</body>
</html>
