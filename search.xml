<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2Fgraph_slam%2F</url>
    <content type="text"><![CDATA[@startuml概率图 —&gt; 因子图 :slam概率图 —&gt; 贝叶斯网络 :机器学习概率图 —&gt; 马尔克夫随机场:机器学习class 因子图 { 可以用公式表达不同的问题 }因子图 —&gt; 非线性因子图因子图 —&gt; 线性因子图非线性因子图 { //非线性优化技巧: 反复求解大型稀疏性系统 }@enduml]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Freal-time-loop-closure-in-2d-lidar-slam%2F</url>
    <content type="text"><![CDATA[摘要LIDAR SLAM是获取平面地图的有效方法。 构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和闭环。 为了实现实时闭环，我们使用branch-and-bound将扫描到Submap匹配计算为约束。 I. 简介本文的贡献是一种新的方法，用于降低计算激光数据的闭环约束的需求量。 II. 相关工作Scan-to-scan matching经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 它的缺点是很快就会累积误差。 Scan-to-map matching有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的Scan-to-map matching是有效且稳健的。在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。 pixel-accurate scan matching方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于闭环检测很有用。 一些方法着重于通过匹配激光扫描的提取特征来改善计算成本[4]。其他用于闭环检测方法包括基于直方图的匹配[6]，扫描数据中的特征检测，以及使用机器学习[7]。 解决累积局部误差的两种常用方法是粒子滤波器和基于图形的SLAM [2]，[8]。 基于图形的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部scan-to-scan匹配，以及基于Submap特征的直方图的重叠局部图的匹配。 III. 系统概述Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 Laser scans被插入到最优估算位姿的Submap中，假定在短时间内足够准确。 而Scan match发生在最近的Submap上，因此它只取决于最近的扫描，全局误差会累积。 cartographer 定期运行位姿优化来减少误差积累。当一个Submap完成时，就不会再将新的扫描插入其中，它将参与Scan match以获得闭环。所有已完成的Submap和扫描都会自动考虑进行闭环。如果它们基于当前的位姿估计足够接近，则Scan match器试图在Submap中找到扫描。如果在当前估计位姿的搜索窗口中找到足够好的匹配，则将其作为闭环约束添加到优化问题。 通过每隔几秒完成一次优化，我们的经验就是当重新访问位置时立即闭环。这导致了软实时约束，即闭环Scan match必须比添加新扫描更快，否则它会明显落后,闭环失败。我们通过对每个完成的Submap使用branch-and-bound和几个预先计算的网格来实现这一点。 IV. 局部2d slam我们的系统将单独的局部和全局方法结合到2D SLAM中。两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为扫描。在不平的地面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。在我们的局部方法中，每个连续扫描与Submap相匹配，使用非线性优化将扫描与Submap对齐; 该过程称为 real time Scan match,其随着时间累积误差，我们的全局方法将其去除，如第五节所述。 A. ScansSubmap构造是重复对齐scan和Submap坐标帧的迭代过程。随着扫描的原点在$0 \in \Bbb R^2$，我们现在将关于扫描点的信息写为 $H = \lbrace h_c\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$ Submap帧中扫描帧的姿态$\xi$表示为变换$T_\xi$，它将扫描点从扫描帧严格转换为Submap帧，定义为 \newcommand{\xidlt}{\xi_\delta} T\_\xi = \underbrace{ \left( \begin {matrix} cos\xidlt & -sin\xidlt \\ sin\xidlt & sin\xidlt \end{matrix} \right)}_{R_\xi} p + \underbrace{ \left(\begin {matrix} \xi_x \\ \xi_y \end{matrix} \right)}_{t_\xi}. \tag1B. Submaps一些连续扫描用于构建Submap。 这些Submap采用概率网格的形式$M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$，它以给定分辨率r的离散网格点进行映射，例如5厘米。这些值可以被认为是网格点被阻挡的概率。 对于每个网格点，我们将相应的像素定义为最接近该网格点的所有点。每当要将扫描插入概率网格时，计算用于命中的一组网格点和用于未命中的不相交组。对于每次击中，我们将最近的网格点插入到命中集中。对于每个未命中，我们插入与每个像素相关联的网格点，该网格点与扫描原点和每个扫描点之间的一条光线相交，不包括已经在命中集中的网格点。如果每个以前未观察到的网格点位于其中一个集合中，则会为其分配概率$p_{hit}$ 或 $p_{miss}$。如果已经观察到网格点x，我们更新命中和未命中的几率 odds(p) = \frac{p}{1-p}, \tag1 M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1and equivalently for misses 等同于未命中 C. Ceres scan matching在将扫描插入Submap之前，扫描位姿ξ相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到最大概率的扫描位姿。 我们将其视为非线性最小二乘问题 \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2其中$T\xi$根据扫描位姿将$h_k$从scan帧变换到Submap帧。函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。我们使用双三次插值。结果，可以发生区间$[0, 1]$之外的值，但是被认为是无关紧要的。这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。由于这是局部优化，因此需要良好的初始估计。能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。 V. 闭环由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。对于仅几十次连续扫描，累积误差很小。通过创建许多小Submap来处理更大的空间。我们的方法，优化所有扫描和Submap的位姿，遵循稀疏位姿调整[2]。插入扫描的相对位姿存储在内存中，以用于闭环优化。除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由scan和Submap组成的对都被认为是闭环。global scan matcher在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中 A. 优化问题闭环优化，和Scan match一样，也被称为非线性最小二乘问题，它允许轻松添加残差以考虑其他数据。每隔几秒钟，我们使用Ceres [14]来计算解决方案 \underset{\Xi^m,\Xi^n}{argmin} \frac{1}{2}\sum_{ij}\rho(E^2(\xi_i^m,\xi _j^s;\sigma_{ij},\xi_{ij}))\tag{SPA}在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。这种约束的残差E由下式计算 E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4 e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - \left( \begin{matrix} R\_{\xi_i^m}^{-1}(t_{\xi\_i^m}-t_{\xi_j^s}) \\ \xi_{ij} - \xi_{j;\theta}^s \end{matrix} \right).\tag5损失函数$\rho$，例如Huber loss，用于减少当Scan match为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。例如，这可能发生在局部对称环境中，例如办公室隔间。异常值的替代方法包括[16]。 B. 限界分支匹配我们对最佳的像素精确匹配感兴趣 \xi^* = \underset{\xi\in\omega}{argmax}\sum\_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。 通过仔细选择步长来提高效率。我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。我们推导出使用余弦定律 d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\ \xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30 \degree$ w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W\_\theta}{\xi_\theta}\rceil.\tag8这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口， \overline{W} = \{-w\_x,...,w\_x\} \times \{-w\_y,...,w\_y\} \times \{-w\_\theta,...,w\_\theta\}\tag9 W = \{\xi\_0 + (rj\_x, rj\_y, \xi\_\theta j\_\theta):(j\_x,j\_y,j\_\theta) \in \overline{W}\}\tag{10}找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。 相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。有关通用方法，请参见算法2。 这种方法最初是在混合整数线性程序的背景下提出的[17]。关于这个主题的文献很广泛; 见[18]简短概述。主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。叶节点是单体; 每个代表一个可行的解决方案。请注意，算法是准确的。只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。 为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。 1）节点选择：在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。这取决于两件事：良好的上限和良好的当前解决方案。后一部分由DFS帮助，它可以快速评估许多叶节点。由于我们不希望将不良匹配作为闭环约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。算法3是这种方法。 2）分支规则：树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换： \overline {\overline{W}} = \Bigg(\{j\_x,j\_y\} \in \Bbb{Z}^2: \\ \Big\lbrace \begin{array}{l} c\_x \leq j\_x < c\_x + 2^{ch} \\ c\_x \leq j\_x < c\_x + 2^{ch} \end{array} \Big\rbrace \times \lbrace c\_\theta \rbrace \Bigg) ,\tag{11} \overline{W}\_c = \overline{\overline{W}} \cap \overline{W}\tag{12} 叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。 在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口 \overline{W}\_{0,x} = \lbrace -w\_x + 2^{h\_o}:j\_x \in \Bbb Z, 0 \leq 2^{h\_o} \leq 2w\_x \rbrace, \\\ \overline{W}\_{0,x} = \lbrace -w\_x + 2^{h\_o}:j\_x \in \Bbb Z, 0 \leq 2^{h\_o} \leq 2w\_x \rbrace, \\\ \overline{W}\_{0,x} = \lbrace -w\_x + 2^{h\_o}:j\_x \in \Bbb Z, 0 \leq 2^{h\_o} \leq 2w\_x \rbrace, \\\ C\_0 = \overline{W}\_{0,x} \times \overline{W}\_{0,y} \times \overline{W}\_{0,\theta} \times \{h\_0\}. \tag{13}At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$ C\_c = \Big((\lbrace c\_x,c\_x + 2^{c\_h-1}\rbrace \times {c\_y, c\_y + 2^{c\_h-1} \times c\_\theta}) \cap \overline{W}\Big) \times \lbrace c\_h-1 \rbrace \tag{14}3) 计算上界：分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。我们用 score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\ \geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M\_{nearest}(T\xi_{j}h_{k}) \\ \geq\underset{j\in \overline{W_c}}{max}\sum\_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k}).\tag{15}为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。 score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16} M_{precomp}^{ch}(x,y) = \underset {\begin{matrix} x^, \in [x,x+r(2^h-1)] \\ y^, \in [y,y+r(2^h-1)] \end{matrix}} {max} M_{nearest}(x^, , y^,) \tag{17}与叶节点一样使用$\xi_c$。请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。图3给出了这种预先计算的网格的一个例子。 为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。然后我们计算一组预先计算的网格，并开始匹配它。 对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。使用该中间结果，然后构造下一个预先计算的网格。 如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。对于空的值集合，此列表为空。使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。 计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。 参考[1] E. Olson，M3RSM：多对多分辨率Scan match，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。 [2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，稀疏位姿调整2D绘图，在IROS，台湾台北，2010年10月10日。 [3] F. Lu和E. Milios，用于环境绘图的全局一致范围扫描对准，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。 [4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测，Robotica，vol。 32，不。 01，pp.19-41,2014。 [5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，具有完整3D运动估计的灵活且可扩展的SLAM系统，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。 [6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，使用几何地标关系的2D LIDAR扫描中的大规模地点识别，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。 [7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，学习close闭合范围数据循环，国际机器人研究杂志，第一卷。 30，不。 14，pp.1728-1754,2011。 [8] G. Grisetti，C。Stachniss和W. Burgard，通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。 [9] G. D. Tipaldi，M。Braun和K. O. Arras，FLIRT：2D范围数据的兴趣区域，应用于机器人导航，在实验机器人中。 Springer，2014年，第695-710页。]]></content>
  </entry>
  <entry>
    <title><![CDATA[吴恩达《深度学习》系列课程个人笔记]]></title>
    <url>%2Fdeep-learning-AndrewNgDeepLearningNotes%2F</url>
    <content type="text"><![CDATA[k aa]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>Another Tag</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Freal-time-loop-closure-in-2d-lidar-slam-en%2F</url>
    <content type="text"><![CDATA[Real-Time Loop Closure in 2D LIDAR SLAM Abstract 摘要Portable laser range-finders, further referred to as LIDAR, and simultaneous localization and mapping (SLAM) are an efficient method of acquiring as-built floor plans. Generating and visualizing floor plans in real-time helps the operator assess the quality and coverage of capture data. Building a portable capture platform necessitates operating under limited computational resources. We present the approach used in our backpack mapping platform which achieves real-time mapping and loop closure at a 5 cm resolution. To achieve realtime loop closure, we use a branch-and-bound approach for computing scan-to-submap matches as constraints. We provide experimental results and comparisons to other well known approaches which show that, in terms of quality, our approach is competitive with established techniques. LIDAR SLAM是获取平面地图的有效方法。 实时生成和可视化楼层平面图有助于评估捕获数据的质量和覆盖范围。 构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和＂闭环＂。 为了实现实时＂闭环＂，我们使用branch-and-bound将扫描到Submap匹配计算为约束。 我们提供实验结果并与其他众所周知的方法进行比较，这些方法表明，在质量方面，我们的方法与已有技术相比具有竞争力。 I. INTRODUCTION 简介As-built floor plans are useful for a variety of applications.Manual surveys to collect this data for building management tasks typically combine computed-aided design (CAD) with laser tape measures.These methods are slow and, by employing human preconceptions of buildings as collections of straight lines, do not always accurately describe the true nature of the space.Using SLAM, it is possible to swiftly and accurately survey buildings of sizes and complexities that would take orders of magnitude longer to survey manually.Applying SLAM in this field is not a new idea and is not the focus of this paper.Instead, the contribution of this paper is a novel method for reducing the computational requirements of computing loop closure constraints from laser range data.This technique has enabled us to map very large floors, tens-of-thousands of square meters, while providing the operator fully optimized results in real-time. 竣工平面图适用于各种应用。用于收集建筑物管理任务的数据的人工调查通常将计算机辅助设计（CAD）与激光卷尺相结合。这些方法很慢，并且通过将人类对建筑物的偏见视为直线的集合，并不总是准确地描述空间的真实性质。使用SLAM，可以快速准确地调查大小和复杂度的建筑物，这些建筑物需要花费更大的数量级才能手动调查。在这个领域应用SLAM并不是一个新想法，也不是本文的重点。相反，本文的贡献是一种新的方法，用于降低计算激光范围数据的闭环约束的计算要求。这项技术使我们能够绘制数十万平方米的非常大的楼层，同时为操作员提供实时全面优化的结果。 II. RELATED WORK 相关工作Scan-to-scan matching is frequently used to compute relative pose changes in laser-based SLAM approaches, for example [1]–[4].On its own, however, scan-to-scan matching quickly accumulates error.Scan-to-map matching helps limit this accumulation of error. One such approach, which uses Gauss-Newton to find local optima on a linearly interpolated map, is [5].In the presence of good initial estimates for the pose, provided in this case by using a sufficiently high data rate LIDAR, locally optimized scan-to-map matching is efficient and robust.On unstable platforms, the laser fan is projected onto the horizontal plane using an inertial measurement unit (IMU) to estimate the orientation of gravity.Pixel-accuratescan matching` approaches, such as [1], further reduce local error accumulation. Although computationally more expensive, this approach is also useful forloop closure detection. Some methods focus on *improving on* the computational cost by matching onextracted featuresfrom the laser scans [4]. Other approaches (forloop closure detection) includehistogram-based matching[6],feature detectionin scan data, and usingmachine learning[7]. Two common approaches foraddressing the remaining local error accumulationareparticle filterandgraph-basedSLAM [2], [8].Particle filtersmust maintain a representation of the full system state in each particle. Forgrid-based SLAM, this quickly becomes resource intensive as maps become large; e.g. one of our test cases is 22,000 m2 collected over a 3 km trajectory. Smaller dimensional feature representations, such as [9], which do not require a grid map for each particle, may be used to reduce resource requirements. When an up-todate grid map is required, [10] suggests computing submaps, which are updated only when necessary, such that the final map is the rasterization of all submaps.Graph-basedapproaches work over a collection of nodes representing poses and features. Edges in the graph are constraints generated from observations. Various optimization methods may be used to minimize the error introduced by all constraints, e.g. [11], [12]. Such a system for outdoor SLAM that uses a graph-based approach, localscan-to-scan` matching, and matching of overlapping local maps based on histograms of submap features is described in [13]. Scan-to-scan matching经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 然而，就其本身而言，Scan-to-scan matching很快就会累积误差。 Scan-to-map matching有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的Scan-to-map matching是有效且稳健的。在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。 pixel-accurate scan matching方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于闭环检测也很有用。一些方法着重于通过匹配激光扫描的提取特征来改善计算成本[4]。其他方法（用于闭环检测）包括基于直方图的匹配[6]，扫描数据中的特征检测，以及使用机器学习[7]。 解决累积局部误差的两种常用方法是粒子滤波器和基于图形的SLAM [2]，[8]。 粒子滤波器必须保持每个粒子中完整系统状态的表示。 对于基于网格的SLAM，随着地图变大，这很快变得资源密集;例如我们的一个测试案例是在3公里的轨道上收集了22,000平方米。 较小的维度特征表示，例如[9]，其不需要每个粒子的网格图，可用于减少资源需求。 当需要最新的网格图时，[10]建议计算Submap，仅在必要时更新，以便最终的图是所有Submap的光栅化。 基于图形的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部scan-to-scan匹配，以及基于Submap特征的直方图的重叠局部图的匹配。 III. SYSTEM OVERVIEW 系统概述Google’s Cartographer provides a real-time solution for indoor mapping in the form of a sensor equipped backpack that generates 2D grid maps with a r = 5 cm resolution.The operator of the system can see the map being created while walking through a building.Laser scans are inserted into a submap at the best estimated position, which is assumed to be sufficiently accurate for short periods of time.Scan matching happens against a recent submap, so it only depends on recent scans, and the error of pose estimates in the world frame accumulates.To achieve good performance with modest hardware requirements, our SLAM approach does not employ a particle filter.To cope with the accumulation of error, we regularly run a pose optimization.When a submap is finished, that is no new scans will be inserted into it anymore, it takes part inscan matchingfor loop closure.All finished submaps and scans are automatically considered for loop closure.If they are close enough based on current pose estimates, a scan matcher tries to find the scan in the submap.If a sufficiently good match is found in a search window around the currently estimated pose, it is added as a loop closing constraint to the optimization problem.By completing the optimization every few seconds, the experience of an operator is that loops are closed immediately when a location is revisited.This leads to the soft real-time constraint that the loop closurescan matching` has tohappen quickerthannew scans are added, otherwise it falls behind noticeably. We achieve this by using abranch-and-bound approachand severalprecomputed grids` per finished submap. Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 Laser scans被插入到最优估算位置的Submap中，假定在短时间内足够准确。 而Scan match发生在最近的Submap上，因此它只取决于最近的扫描，全局误差会累积。 为了在适度的硬件要求下获得良好的性能，我们的SLAM方法不使用粒子滤波器。cartographer 定期运行位姿优化来减少误差积累。当一个Submap完成时，就不会再将新的扫描插入其中，它将参与Scan match以获得闭环。所有已完成的Submap和扫描都会自动考虑进行＂闭环＂。如果它们基于当前的位姿估计足够接近，则Scan match器试图在Submap中找到扫描。如果在当前估计位姿的搜索窗口中找到足够好的匹配，则将其作为闭环约束添加到优化问题。 通过每隔几秒完成一次优化，我们的经验就是当重新访问位置时立即闭环。这导致了软实时约束，即闭环Scan match必须比添加新扫描更快，否则它会明显落后,闭环失败。 我们通过对每个完成的Submap使用branch-and-bound和几个预先计算的网格`来实现这一点。 IV. LOCAL 2D SLAM 局部2d slamOur system combines separate local and global approaches to 2D SLAM.Both approaches optimize the pose, $\xi = (\xi_x, \xi_y, \xi_\delta)$ consisting of a $(x, y)$ translation and a rotation $\xi_\delta$, of LIDAR observations, which are further referred to as scans.On an unstable platform, such as our backpack, an IMU is used to estimate the orientation of gravity for projecting scans from the horizontally mounted LIDAR into the 2D world.In our local approach, each consecutive scan is matched against a small chunk of the world, called a submap M, using a non-linear optimization that aligns the scan with the submap; this process is further referred to as scan matching.Scan matching accumulates error over time that is later removed by our global approach, which is described in Section V . 我们的系统将单独的局部和全局方法结合到2D SLAM中。两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为扫描。在不稳定的平面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。在我们的局部方法中，每个连续扫描与世界的一小块相匹配，称为Submap，使用非线性优化将扫描与Submap对齐; 该过程进一步称为Scan match。Scan match随着时间累积误差，后来我们的全局方法将其去除，如第五节所述。 A. ScansSubmap construction is the iterative process of repeatedly aligning scan and submap coordinate frames, further referred to as frames.With the origin of the scan at $0 \in \Bbb R^2$ , we now write the information about the scan points as $H = \lbrace h_k\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$ .The pose $\xi$ of the scan frame in the submap frame is represented as the transformation $T_\xi$, which rigidly transforms scan points from the scan frame into the submap frame, defined as T_\xi = \underbrace{ \left( \begin {matrix} cos\xi_\delta & -sin\xi_\delta \\ sin\xi_\delta & sin\xi_\delta \end{matrix} \right)}_{R_\xi} p + \underbrace{ \left(\begin {matrix} \xi_x \\ \xi_y \end{matrix} \right)}_{t_\xi}. \tag1B. SubmapsA few consecutive scans are used to build a submap.These submaps take the form of probability grids $M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$ which map from discrete grid points at a given resolution r, for example 5 cm, to values.These values can be thought of as the probability that a grid point is obstructed.For each grid point, we define the corresponding pixel to consist of all points that are closest to that grid point.Whenever a scan is to be inserted into the probability grid, a set of grid points for hits and a disjoint set for misses are computed.For every hit, we insert the closest grid point into the hit set.For every miss, we insert the grid point associated with each pixel that intersects one of the rays between the scan origin and each scan point, excluding grid points which are already in the hit set.Every formerly unobserved grid point is assigned a probability $p_{hit}$ or $p_{miss}$ if it is in one of these sets.If the grid point x has already been n observed, we update the odds for hits and misses as odds(p) = \frac{p}{1-p}, \tag1 M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1and equivalently for misses 等同于未命中 C. Ceres scan matchingPrior to inserting a scan into a submap, the scan pose $\xi$ is optimized, relative to the current local submap,(using a Ceresbased [14] scan matcher). The scan matcher is responsible for finding a scan pose that maximizes the probabilities at the scan points in the submap. We cast this as a nonlinear least squares problem 在将扫描插入Submap之前，扫描位姿ξ相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到最大概率的扫描位姿。 我们将其视为非线性最小二乘问题 \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2where $T\xi$ transforms $h_k$ from the scan frame to the submap frame according to the scan pose.The function $M_{smooth} : \Bbb R^2 → \Bbb R$ is a smooth version of the probability values in the local submap.We use bicubic interpolation.As a result, values outside the interval $[0, 1]$ can occur but are considered harmless. 其中$T\xi$根据扫描位姿将$h_k$从扫描帧变换到Submap帧。函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。我们使用双三次插值。结果，可以发生区间$[0, 1]$之外的值，但是被认为是无害的。 Mathematical optimization of this smooth function usually gives better precision than the resolution of the grid.Since this is a local optimization, good initial estimates are required.An IMU capable of measuring angular velocities can be used to estimate the rotational component $\theta$ of the pos between scan matches.A higher frequency of scan matches or a pixel-accuratescan matching`` approach, although more computationally intensive, can be used in the absence of an IMU. 这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。由于这是局部优化，因此需要良好的初始估计。能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。 V. CLOSING LOOPS 闭环As scans are only matched against a submap containing a few recent scans, the approach described above slowly accumulates error.For only a few dozen consecutive scans, the accumulated error is small.Larger spaces are handled by creating many small submaps.Our approach, optimizing the poses of all scans and submaps, follows Sparse Pose Adjustment [2].The relative poses where scans are inserted are stored in memory for use in the loop closing optimization.In addition to these relative poses, all other pairs consisting of a scan and a submap are considered for loop closing once the submap no longer changes.A scan matcher is run in the background and if a good match is found, the corresponding relative pose is added to the optimization problem 由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。对于仅几十次连续扫描，累积误差很小。通过创建许多小Submap来处理更大的空间。我们的方法，优化所有扫描和Submap的位姿，遵循”稀疏位姿调整”[2]。插入扫描的相对位姿存储在存储器中，以用于＂闭环＂优化。除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由扫描和Submap组成的对都被认为是＂闭环＂。Scan match器在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中 A. Optimization problemLoop closure optimization, like scan matching, is also formulated as a nonlinear least squares problem which allows easily adding residuals to take additional data into account.Once every few seconds, we use Ceres [14] to compute a solution to ＂闭环＂优化，如Scan match，也被称为非线性最小二乘问题，它允许轻松添加残差以考虑其他数据。每隔几秒钟，我们使用Ceres [14]来计算解决方案 \underset{\Xi^m,\Xi^n}{argmin} \frac{1}{2}\sum_{ij}\rho(E^2(\xi _i^m,\xi _j^s;\sigma_{ij},\xi_{ij}))\tag{SPA}where the submap poses $\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$ and the scan poses $\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$ in the world are optimized given some constraints.These constraints take the form of relative poses $\xi_{ij}$ and associated covariance matrices $\Sigma_ij$ .For a pair of submap i and scan j, the pose ξij describes where in the submap coordinate frame the scan was matched.The covariance matrices Σij can be evaluated, for example, following the approach in [15], or locally using the covariance estimation feature of Ceres [14] with (CS).The residual E for such a constraint is computed by 在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。这种约束的残差E由下式计算 E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4 e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - \left( \begin{matrix} R_{\xi_i^m}^{-1}(t_{\xi_i^m}-t_{\xi_j^s}) \\ \xi_{ij} - \xi_{j;\theta}^s \end{matrix} \right).\tag5A loss function $\rho$, for example Huber loss, is used to reduce the influence of outliers which can appear in (SPA) when scan matching adds incorrect constraints to the optimization problem.For example, this may happen in locally symmetric environments, such as office cubicles.Alternative approaches to outliers include [16]. 损失函数$\rho$，例如Huber loss，用于减少当Scan match为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。例如，这可能发生在局部对称环境中，例如办公室隔间。异常值的替代方法包括[16]。 B. Branch-and-bound scan matchWe are interested in the optimal, pixel-accurate match 我们对最佳的像素精确匹配感兴趣 \xi^* = \underset{\xi\in\omega}{argmax}\sum_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}where $\omega$ is the search window and $M_{nearest}$ is M extended to all of $\Bbb R^2$ by rounding its arguments to the nearest grid point first, that is extending the value of a grid points to the corresponding pixel.The quality of the match can be improved further using (CS). 其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。 Efficiency is improved by carefully choosing step sizes.We choose the angular step size $\xi_\theta$ so that scan points at the maximum range $d_{max}$ do not move more than $r$, the width of one pixel.Using the law of cosines, we derive 通过仔细选择步长来提高效率。我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。我们推导出使用余弦定律 d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\ \xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7We compute an integral number of steps covering given linear and angular search window sizes, e.g., $W_x = W_y = 7m$ and $W_\theta = 30\degree$ 我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30\degree$ w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W_\theta}{\xi_\theta}\rceil.\tag8This leads to a finite set $W$ forming a search window around an estimate $\xi_\theta$ placed in its center, 这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口， \overline{W} = \{-w_x,...,w_x\} \times \{-w_y,...,w_y\} \times \{-w_\theta,...,w_\theta\}\tag9 W = \{\xi_0 + (rj_x, rj_y, \xi_\theta j_\theta):(j_x,j_y,j_\theta) \in \overline{W}\}\tag{10}A naive algorithm to find $\xi^*$ can easily be formulated, see Algorithm 1, but for the search window sizes we have in mind it would be far too slow . 找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。1algo Instead, we use a branch and bound approach to efficiently compute $\xi^*$ over larger search windows.See Algorithm 2 for the generic approach.This approach was first suggested in the context of mixed integer linear programs [17].Literature on the topic is extensive; see [18] for a short overview.The main idea is to represent subsets of possibilities as nodes in a tree where the root node represents all possible solutions, $W$ in our case.The children of each node form a partition of their parent, so that they together represent the same set of possibilities.The leaf nodes are singletons; each represents a single feasible solution.Note that the algorithm is exact.It provides the same solution as the naive approach as long as the score(c) of inner nodes c is an upper bound on the score of its elements.In that case, whenever a node is bounded, a solution better than the best known solution so far does not exist in this subtree. 相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。有关通用方法，请参见算法2。这种方法最初是在混合整数线性程序的背景下提出的[17]。关于这个主题的文献很广泛; 见[18]简短概述。主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。叶节点是单体; 每个代表一个可行的解决方案。请注意，算法是准确的。只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。 To arrive at a concrete algorithm, we have to decide on the method of node selection, branching, and computation of upper bounds. 为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。 1) Node selection:Our algorithm uses depth-first search (DFS) as the default choice in the absence of a better alternative: The efficiency of the algorithm depends on a large part of the tree being pruned.This depends on two things: a good upper bound, and a good current solution.The latter part is helped by DFS, which quickly evaluates many leaf nodes.Since we do not want to add poor matches as loop closing constraints, we also introduce a score threshold below which we are not interested in the optimal solution.Since in practice the threshold will not often be surpassed, this reduces the importance of the node selection or finding an initial heuristic solution.Regarding the order in which the children are visited during the DFS, we compute the upper bound on the score for each child, visiting the most promising child node with the largest bound first.This method is Algorithm 3. 1）节点选择： 在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。这取决于两件事：良好的上限和良好的当前解决方案。后一部分由DFS帮助，它可以快速评估许多叶节点。由于我们不希望将不良匹配作为＂闭环＂约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。算法3是这种方法。 2) Branching rule: Each node in the tree is described by a tuple of integers $c = (c_x, c_y, c_θ, c_h) \in \Bbb Z^4$.Nodes at height ch combine up to $2^{ch}\times2^{ch}$ possible translations but represent a specific rotation: 2）分支规则： 树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换： \overline {\overline{W}} = (\{j_x,j_y\} \in \Bbb{Z}^2:\\ \left. \begin{array}{l} c_x \leq j_x < c_x + 2^{ch}\\ c_x \leq j_x < c_x + 2^{ch} \end{array} \right\} \times \{c_\theta\},\tag11 \overline{W}_c = \overline{\overline{W}} \cap \overline{W}\tag{12}1algo2 1algo3 Leaf nodes have height ch = 0, and correspond to feasible solutions $W\ni \xi_c=\xi_0+(rc_x,rc_y,\xi_\theta c_\theta)$. 叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。 In our formulation of Algorithm 3, the root node, encompassing all feasible solutions, does not explicitly appear and branches into a set of initial nodes $C_0$ at a fixed height $h_0$ covering the search window 在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口 \overline{W}_{0,x} = \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\ \overline{W}_{0,x} = \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\ \overline{W}_{0,x} = \{ -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \} \\ C_0 = \overline{W}_{0,x} \times \overline{W}_{0,y} \times \overline{W}_{0,\theta} \times \{h_0\} \tag{13}At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$ C_c = ((\{c_x,c_x + 2^{c_h-1}\} \times {c_y, c_y + 2^{c_h-1} \times c_\theta}) \cap \overline{W}) \times \{c_h-1\}\tag{14}3) Computing upper bounds:The remaining part of the branch and bound approach is an efficient way to compute upper bounds at inner nodes, both in terms of computational effort and in the quality of the bound.We use3）计算上界： 分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。我们用 score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\ \geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M_{nearest}(T\xi_{j}h_{k})\\ \underset{j\in \overline{W_c}}{max}\sum_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k})\tag{15}To be able to compute the maximum efficiently, we use precomputed grids $M_{precomp}^{ch}$.Precomputing one grid per possible height $c_h$ allows us to compute the score with effor linear in the number of scan points.Note that, to be able to do this, we also compute the maximum over $\overline{\overline{W_c}}$ which can be larger than $\overline{W_c}$near the boundary of our search space. 为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。 score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16} M_{precomp}^{ch}(x,y) = \underset {\begin{matrix} x^, \in [x,x+r(2^h-1)] \\ y^, \in [y,y+r(2^h-1)] \end{matrix}} {max} M_{nearest}(x^, , y^,) \tag{17}with $\xi_c$ as before for the leaf nodes.Note that Mh precomp has the same pixel structure as $M_{nearest}$, but in each pixel storing the maximum of the values of the $2^h \times 2^h$ box of pixels beginning there.An example of such precomputed grids is given in Figure 3.与叶节点一样使用$\xi_c$。请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。图3给出了这种预先计算的网格的一个例子。 To keep the computational effort for constructing the precomputed grids low, we wait until a probability grid will receive no further updates.Then we compute a collection of precomputed grids, and start matching against it. 为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。然后我们计算一组预先计算的网格，并开始匹配它。 For each precomputed grid, we compute the maximum of a $2^h$ pixel wide row starting at each pixel.Using this intermediate result, the next precomputed grid is then constructed. 对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。使用该中间结果，然后构造下一个预先计算的网格。 The maximum of a changing collection of values can be kept up-to-date in amortized $O(1)$ if values are removed in the order in which they have been added.Successive maxima are kept in a deque that can be defined recursively as containing the maximum of all values currently in the collection followed by the list of successive maxima of all values after the first occurrence of the maximum.For an empty collection of values, this list is empty.Using this approach, the precomputed grids can be computed in $O(n)$ where n is the number of pixels in each precomputed grids. 如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。对于空的值集合，此列表为空。使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。 An alternative way to compute upper bounds is to compute lower resolution probability grids, successively halving the resolution, see [1].Since the additional memory consumption of our approach is acceptable, we prefer it over using lower resolution probability grids which lead to worse bounds than (15) and thus negatively impact performance. 计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。 VI. EXPERIMENTAL RESULTS 实验结果In this section, we present some results of our SLAM algorithm computed from recorded sensor data using the same online algorithms that are used interactively on the backpack.First, we show results using data collected by the sensors of our Cartographer backpack in the Deutsches Museum in Munich.Second, we demonstrate that our algorithms work well with inexpensive hardware by using data collected from a robotic vacuum cleaner sensor.Lastly, we show results using the Radish data set [19] and compare ourselves to published results. 在本节中，我们使用在背包上交互使用的相同在线算法，从记录的传感器数据中计算出我们的SLAM算法的一些结果。首先，我们使用慕尼黑德意志博物馆的Cartographer背包传感器收集的数据显示结果。其次，我们通过使用从机器人真空吸尘器传感器收集的数据证明我们的算法可以很好地与廉价的硬件配合使用。最后，我们使用萝卜数据集[19]显示结果，并将自己与已发布的结果进行比较。 A. Real-World Experiment: Deutsches MuseumUsing data collected at the Deutsches Museum spanning 1,913 s of sensor data or 2,253 m (according to the computed solution), we computed the map shown in Figure 4.On a workstation with an Intel Xeon E5-1650 at 3.2 GHz, our SLAM algorithm uses 1,018 s CPU time, using up to 2.2 GB of memory and up to 4 background threads for loop closure scan matching.It finishes after 360 s wall clock time, meaning it achieved 5.3 times real-time performance.The generated graph for the loop closure optimization consists of 11,456 nodes and 35,300 edges.The optimization problem (SPA) is run every time a few nodes have been added to the graph.A typical solution takes about 3 iterations, and finishes in about 0.3 s. 使用在德意志博物馆收集的数据，跨越1,913秒的传感器数据或2,253米（根据计算的解决方案），我们计算出如图4所示的地图。在具有3.2 GHz的Intel Xeon E5-1650的工作站上，我们的SLAM算法使用1,018秒的CPU时间，使用高达2.2 GB的内存和最多4个后台线程进行闭环Scan match。它在360秒的挂钟时间后完成，这意味着它实现了5.3倍的实时性能。生成的＂闭环＂优化图由11,456个节点和35,300个边组成。每次向图表添加几个节点时都会运行优化问题（SPA）。典型的解决方案需要大约3次迭代，并在大约0.3秒内完成。 B. Real-World Experiment: Neato’s Revo LDSNeato Robotics uses a laser distance sensor (LDS) called Revo LDS [20] in their vacuum cleaners which costs under $ 30.We captured data by pushing around the vacuum cleaner on a trolley while taking scans at approximately 2 Hz over its debug connection.Figure 5 shows the resulting 5 cm resolution floor plan.To evaluate the quality of the floor plan, we compare laser tape measurements for 5 straight lines to the pixel distance in the resulting map as computed by a drawing tool.The results are presented in Table I, all values are in meters.The values are roughly in the expected order of magnitude of one pixel at each end of the line. Neato Robotics在其真空吸尘器中使用名为Revo LDS [20]的激光距离传感器（LDS），售价低于30美元。我们通过推动手推车上的真空吸尘器捕获数据，同时通过其调试连接以大约2 Hz的速度进行扫描。图5显示了5厘米分辨率的平面图。为了评估平面图的质量，我们将5条直线的激光带测量结果与绘图工具计算得到的地图中的像素距离进行比较。结果如表I所示，所有数值均以米为单位。这些值大致在线的每一端的一个像素的预期数量级。 We compare our approach to others using the benchmark measure suggested in [21], which compares the error in relative pose changes to manually curated ground truth relations.Table II shows the results computed by our Cartographer SLAM algorithm.For comparison, we quote results for Graph Mapping (GM) from [21].Additionally, we quote more recently published results from [9] in Table III.All errors are given in meters and degrees, either absolute or squared, together with their standard deviation.Each public data set was collected with a unique sensor configuration that differs from our Cartographer backpack.Therefore, various algorithmic parameters needed to be adapted to produce reasonable results.In our experience, tuning Cartographer is only required to match the algorithm to the sensor configuration and not to the specific surroundings. 我们使用[21]中建议的基准测量法将我们的方法与其他方法进行比较，后者将相对姿态变化的误差与手动策划的地面实况关系进行比较。表II显示了我们的制图师SLAM算法计算的结果。为了比较，我们引用[21]中的图形构图（GM）的结果。此外，我们引用表III中最近公布的[9]结果。所有误差均以米和度给出，绝对值或平方值，以及它们的标准偏差。每个公共数据集都采用独特的传感器配置进行收集，该配置与我们的Cartographer背包不同。因此，需要调整各种算法参数以产生合理的结果。根据我们的经验，调整制图师只需要将算法与传感器配置相匹配，而不是与特定环境相匹配。 Since each public data set has a unique sensor configuration, we cannot be sure that we did not also fit our parameters to the specific locations. The only exception being the Freiburg hospital data set where there are two separate relations files. We tuned our parameters using the local relations but also see good results on the global relations. 由于每个公共数据集都有一个独特的传感器配置，我们无法确定，我们也不适合我们的参数到特定的位置。 唯一的例外是弗莱堡医院数据集，其中有两个独立的关系文件。 我们使用当地关系调整了参数，但也看到了全局关系的良好结果。 The most significant differences between all data sets is the frequency and quality of the laser scans as well as the availability and quality of odometry.所有数据集之间最显着的差异是激光扫描的频率和质量以及测距的可用性和质量。 Despite the relatively outdated sensor hardware used in the public data sets, Cartographer SLAM consistently performs within our expectations, even in the case of MIT CSAIL, where we perform considerably worse than Graph Mapping.For the Intel data set, we outperform Graph Mapping, but not Graph FLIRT.For MIT Killian Court we outperform Graph Mapping in all metrics.In all other cases, Cartographer outperforms both Graph Mapping and Graph FLIRT in most but not all metrics尽管公共数据集中使用了相对过时的传感器硬件，但Cartographer SLAM始终如一地符合我们的预期，即使在MIT CSAIL的情况下，我们的表现也比图谱构图差得多。对于英特尔数据集，我们优于图形构图，但不是图形FLIRT。对于MIT Killian Court，我们在所有指标中都超越了图形构图。在所有其他情况下，Cartographer在大多数但不是所有指标中都优于图形构图和图形FLIRT Since we add loop closure constraints between submaps and scans, the data sets contain no ground truth for them.It is also difficult to compare numbers with other approaches based on scan-to-scan.Table IV shows the number of loop closure constraints added for each test case (true and false positives), as well as the precision, that is the fraction of true positives.We determine the set of true positive constraints to be the subset of all loop closure constraints which are not violated by more than 20 cm or 1 ◦ when we compute (SPA).We see that while our scan-to-submap matching procedure produces false positives which have to be handled in the optimization (SPA), it manages to provide a sufficient number of loop closure constraints in all test cases.Our use of the Huber loss in (SPA) is one of the factors that renders loop closure robust to outliers.In the Freiburg hospital case, the choice of a low resolution and a low minimum score for the loop closure detection produces a comparatively high rate of false positives.The precision can be improved by raising the minimum score for loop closure detection, but this decreases the solution quality in some dimensions according to ground truth.The authors believe that the ground truth remains the better benchmark of final map quality. 由于我们在Submap和扫描之间添加了＂闭环＂约束，因此数据集中不包含基础事实。将数字与基于scan-to-scan的其他方法进行比较也很困难。表IV显示了为每个测试用例添加的＂闭环＂约束的数量（真和假阳性），以及精度，即真阳性的分数。我们确定真正的正约束集合是所有＂闭环＂约束的子集，当我们计算（SPA）时，它们不会超过20厘米或1秒。我们看到，虽然我们的扫描到Submap匹配过程产生必须在优化（SPA）中处理的误报，但它设法在所有测试用例中提供足够数量的＂闭环＂约束。我们在（SPA）中使用Huber损失是使＂闭环＂对异常值具有鲁棒性的因素之一。在弗莱堡医院案例中，对闭环检测的低分辨率和低最低分数的选择产生相对较高的误报率。通过提高闭环检测的最小分数可以提高精度，但是根据基础事实，这会降低某些维度的解决方案质量。作者认为，基础事实仍然是最终地图质量的更好基准。 The parameters of Cartographer’s SLAM were not tuned for CPU performance.We still provide the wall clock times in Table V which were again measured on a workstation with an Intel Xeon E5-1650 at 3.2 GHz.We provide the duration of the sensor data for comparison. Cartographer的SLAM参数没有针对CPU性能进行调整。我们仍然提供表V中的挂钟时间，这些时间再次在具有3.2 GHz的Intel Xeon E5-1650的工作站上测量。我们提供传感器数据的持续时间以供比较。 VII. CONCLUSIONS 结论In this paper, we presented and experimentally validated a 2D SLAM system that combines scan-to-submap matching with loop closure detection and graph optimization.Individual submap trajectories are created using our local, grid-based SLAM approach.In the background, all scans are matched to nearby submaps using pixel-accuratescan matching` to createloop closure constraints`.The constraint graph of submap and scan poses is periodically optimized in the background.The operator is presented with an upto-date preview of the final map as a GPU-accelerated combination of finished submaps and the current submap.We demonstrated that it is possible to run our algorithms on modest hardware in real-time. 在本文中，我们提出并实验验证了一个2D SLAM系统，该系统将扫描到Submap匹配与＂闭环＂检测和图形优化相结合。使用我们的基于网格的局部SLAM方法创建单个Submap轨迹。在后台，所有扫描都使用像素精确Scan match匹配到附近的Submap，以创建＂闭环＂约束。Submap和扫描位姿的约束图在后台定期优化。向操作员呈现最终地图的最新预览，作为完成的子地图和当前子地图的GPU加速组合。我们证明了可以在适度的硬件上实时运行我们的算法。 ACKNOWLEDGMENTS 致谢This research has been validated through experiments in the Deutsches Museum, Munich.The authors thank its administration for supporting our work.Comparisons were done using manually verified relations and results from [21] which uses data from the Robotics Data Set Repository (Radish) [19].Thanks go to Patrick Beeson, Dieter Fox, Dirk Hahnel, Mike Bosse, John Leonard, ¨ Cyrill Stachniss for providing this data.The data for the Freiburg University Hospital was provided by Bastian Steder, Rainer Kummerle, Christian Dornhege, Michael Ruhnke, ¨ Cyrill Stachniss, Giorgio Grisetti, and Alexander Kleiner. 这项研究已通过慕尼黑德意志博物馆的实验得到验证。作者感谢其政府支持我们的工作。使用手动验证的关系和来自[21]的结果进行比较，该结果使用来自机器人数据集库（Radish）[19]的数据。感谢Patrick Beeson，Dieter Fox，Dirk Hahnel，Mike Bosse，John Leonard，Cyrill Stachniss提供这些数据。弗赖堡大学医院的数据由Bastian Steder，Rainer Kummerle，Christian Dornhege，Michael Ruhnke，Cyrill Stachniss，Giorgio Grisetti和Alexander Kleiner提供。 REFERENCES 参考[1] E. Olson, M3RSM: Many-to-many multi-resolutionscan matching, in Proceedings of the IEEE International Conference on Robotics and Automation (ICRA), June 2015.[2] K. Konolige, G. Grisetti, R. Kummerle, W. Burgard, B. Limketkai, ¨ and R. Vincent, Sparse pose adjustment for 2D mapping, in IROS, Taipei, Taiwan, 10/2010 2010.[3] F. Lu and E. Milios, Globally consistent range scan alignment for environment mapping, Autonomous robots, vol. 4, no. 4, pp. 333– 349, 1997.[4] F. Mart´ın, R. Triebel, L. Moreno, and R. Siegwart, Two different tools for three-dimensional mapping: DE-basedscan matchingand feature-based loop detection, Robotica, vol. 32, no. 01, pp. 19–41, 2014.[5] S. Kohlbrecher, J. Meyer, O. von Stryk, and U. Klingauf, A flexible and scalable SLAM system with full 3D motion estimation, in Proc. IEEE International Symposium on Safety, Security and Rescue Robotics (SSRR). IEEE, November 2011.[6] M. Himstedt, J. Frost, S. Hellbach, H.-J. Bohme, and E. Maehle, ¨ Large scale place recognition in 2D LIDAR scans using geometrical landmark relations, in Intelligent Robots and Systems (IROS 2014), 2014 IEEE/RSJ International Conference on. IEEE, 2014, pp. 5030– 5035.[7] K. Granstrom, T. B. Sch ¨ on, J. I. Nieto, and F. T. Ramos, Learning to ¨ close loops from range data, The International Journal of Robotics Research, vol. 30, no. 14, pp. 1728–1754, 2011.[8] G. Grisetti, C. Stachniss, and W. Burgard, Improving grid-based SLAM with Rao-Blackwellized particle filters by adaptive proposals and selective resampling, in Robotics and Automation, 2005. ICRA 2005. Proceedings of the 2005 IEEE International Conference on. IEEE, 2005, pp. 2432–2437.[9] G. D. Tipaldi, M. Braun, and K. O. Arras, FLIRT: Interest regions for 2D range data with applications to robot navigation, in Experimental Robotics. Springer, 2014, pp. 695–710. 1875/5000[1] E. Olson，M3RSM：多对多分辨率Scan match，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。[2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，&quot;稀疏位姿调整&quot;2D绘图，在IROS，台湾台北，2010年10月10日。[3] F. Lu和E. Milios，用于环境绘图的全局一致范围扫描对准，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。[4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测，Robotica，vol。 32，不。 01，pp.19-41,2014。[5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，具有完整3D运动估计的灵活且可扩展的SLAM系统，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。[6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，使用几何地标关系的2D LIDAR扫描中的大规模地点识别，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。[7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，学习close闭合范围数据循环，国际机器人研究杂志，第一卷。 30，不。 14，pp.1728-1754,2011。[8] G. Grisetti，C。Stachniss和W. Burgard，通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。[9] G. D. Tipaldi，M。Braun和K. O. Arras，FLIRT：2D范围数据的兴趣区域，应用于机器人导航，在实验机器人中。 Springer，2014年，第695-710页。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Flocal_slam%2F</url>
    <content type="text"><![CDATA[LocalTrajectoryBuilderReturns ‘MatchingResult’ when range data accumulation completed,otherwise ‘nullptr’. Range data must be approximately horizontalfor 2D SLAM. TimedPointCloudData::time is when the last point inrange_data was acquired, TimedPointCloudData::ranges contains therelative time of point with respect to TimedPointCloudData::time. LocalTrajectoryBuilderAddImuData添加imuData extrapolator_局部地图的位姿推断器。cartographer_ros不一样,addImuData时添加 雷达数据的处理过程Node::HandleLaserScanMessageSensorBridge::HandleLaserScanMessage ToPointCloudWithIntensities HandleLaserScan HandleRangefinderCollatedTrajectoryBuilder AddSensorData AddDataCollator::AddSensorDataOrderedMultiQueue::Add Dispatch callback global_trajectory_builder::AddSensorDataLocalTrajectoryBuilder2D::AddRangeDataRangeDataCollator::AddRangeData extrapolator_-&gt;ExtrapolatePose accumulated_range_data_ TransformToGravityAlignedFrameAndFilterAddAccumulatedRangeDataTransformRangeDatalocal_slam_result_callback_OnLocalSlamResultGetTrajectoryStatesscan_matched_point_cloud_publisher_ Imu的处理过程Node::HandleImuMessage sensor_samplers_ 分频，脉冲未到不处理 extrapolators_.at(trajectory_id).AddImuDataSensorBridge::HandleImuMessageCollatedTrajectoryBuilder::AddDataCollator::AddSensorDataOrderedMultiQueue::AddBlockingQueue::Push, Dispatch callbackLocalTrajectoryBuilder2D::AddImuDataPoseExtrapolator::AddImuDataPoseGraph2D::AddImuDataOptimizationProblem2D::AddImuData Odometry的处理过程Node::HandleOdometryMessage sensor_samplers_ 分频，脉冲未到不处理 extrapolators_.at(trajectory_id).AddOdometryData 角速度和线速度SensorBridge::HandleOdometryMessageCollatedTrajectoryBuilder::AddDataCollator::AddSensorDataOrderedMultiQueue::AddBlockingQueue::Push, Dispatch callbackLocalTrajectoryBuilder2D::AddOdometryDataPoseExtrapolator::AddOdometryDataPoseGraph2D::AddOdometryDataOptimizationProblem2D::AddOdometryData]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Fsource_read%2F</url>
    <content type="text"><![CDATA[#目录解析ImuTracker: 使用IMU的角速度和线性加速度跟踪方向。 因为平均线性加速度（假设慢速运动）是重力的直接测量，所以滚动/俯仰不会漂移，尽管是偏航。 Map_build: 使用用于局部子图TrajectoryBuilders和用于闭环的PoseGraph来连接整个SLAM堆栈。成员只有五个 MapBuilderOptions; thread_pool_; pose_graph_; CollatorInterface sensor_collator_; trajectory_builders_ all_trajectory_builder_options_; ,其中pose_graph_用于全局优化， trajectory_builders_用于子地图构建. sensor_collator_ 用于数据收集 我们先看sensor_collator_,sensor_collator_ SensorInterface # 图优化 Real-time correlative scan matching 论文算法分析 Cartographer 的前端算法思路 cartographer Documentation]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Fscan-matching-in-2d-slam%2F</url>
    <content type="text"><![CDATA[【泡泡机器人公开课】第二十三课：Scan Matching in 2D SLAM by 张明明概述 Scan Matching两类Real-Time Loop Cloare in 2D LIDAR SLAM.ICRA2016,提到scan matching的两种方法 scan-to-ccan —ICP,etc 计算成本大 累积误差,需进行闭环 容易进行闭环检测scan-to-map matching —Hector SLAM,etc 误差累积小计算成本小 难以闭环更进一步的算法 2.ICPPL-ICP(开源,ros)典型的是PL-ICP,一般icp是点到点的二阶最小均平和(ICP variant using a point to linear metric ICRA2009),速度快,大的旋转不够鲁棒公式:论文: PL-ICP加闭环（g2o） 关键帧的选择策略 如何闭环对之前的关键帧进行搜索 有一个大的旋转就选择一个关键帧缺点：没有submap(基于视觉的闭环), 有个局部小闭环， google 也是一个小闭环(不开源) Hector Slam]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2Fcartographer_source%2Fturn%2F</url>
    <content type="text"><![CDATA[准备使用1.0.0版本,因为公司扫地机用的是indigo版本,而我本机是用kinect版,所以我使用了docker来查看和调用rvizDocker.indigo需要做些更改 ARG CARTOGRAPHER_VERSION=release-1.0 cmake 升级到3.2版以上 调参第一天先从’/opt/ros/indigo/share/cartographer_ros/configuration’,如果找不到再到’/usr/share/cartographer-ros’找 map 通常是map tracking_frame: 由SLAM算法跟踪的帧的ROS帧ID。如果使用IMU，它应该在其位置，尽管它可能是旋转的。一个常见的选择是“imu_link”。 不明,不用imu,写了odom, published_frame: ROS帧ID用作发布姿势的子帧。例如，如果“odom”帧由系统的不同部分提供，则为“odom”。在这种情况下，map_frame中的“ odom ” 姿势将被发布。否则，将其设置为“base_link”可能是合适的。 不明,写了odom odom_frame: 仅在provide_odom_frame为true时使用。published_frame 和map_frame之间的框架，用于发布（非循环关闭）本地SLAM结果。通常是“odom”。 provide_odom_frame: 如果启用，则本地非闭环连续姿势将作为map_frame中的odom_frame发布。 use_odometry: 如果启用，请在主题“ odom ”上订阅nav_msgs / Odometry。在这种情况下必须提供测距，并且信息将包含在SLAM中 2d use_imu_data 如果不用false先关闭全局slam hit_probability 激光击中黑的程度 miss_probability 激光击不中白的程度 online_correlative_scan_matching 更新initial_ceres_pose位置ceres_scan_matcher_ pose_observation ,summary 流程:整理轨迹生成器 &gt; 添加数据整理轨迹生成器 - &gt; 处理传感器数据整理collated_trajectory_builder| &gt; AddDatacollated_trajectory_builder| | &gt; HandleCollatedSensorData global_trajectory_builder| | | &gt; AddSensorDatalocal_trajectory_builder_2d| | | | &gt; AddRangeData range_data_collator| | | | | &gt; AddRangeDatalocal_trajectory_builder_2d| | | | | &gt; InitializeExtrapolator pose_extrapolator| | | | | &gt; GetLastPoseTime pose_extrapolator| | | | | &gt; ExtrapolatePose pose_extrapolator| | | | | &gt; ExtrapolatePose pose_extrapolator call: 1574 times. | | | | | &gt; EstimateGravityOrientationlocal_trajectory_builder_2d| | | | | &gt; TransformToGravityAlignedFrameAndFilterlocal_trajectory_builder_2d| | | | | &gt; AddAccumulatedRangeData pose_extrapolator| | | | | | &gt; ExtrapolatePoselocal_trajectory_builder_2d| | | | | | &gt; ScanMatch pose_extrapolator| | | | | | &gt; AddPoselocal_trajectory_builder_2d| | | | | | &gt; InsertIntoSubmap pose_graph_2d| | | | &gt; AddNode pose_graph_2d| | | | | &gt; GetLocalToGlobalTransform pose_graph_2d| | | | | &gt; AddTrajectoryIfNeeded pose_graph_2d| | | | | &gt; AddWorkItem pose_graph_2d| | | | | | &gt; ComputeConstraintsForNode pose_graph_2d| | | | | | | &gt; InitializeGlobalSubmapPoses constraint_builder_2d| | | | | | | &gt; ComputeSubmapPose optimization_problem_2d| | | | | | | &gt; AddTrajectoryNode constraint_builder_2d| | | | | | | &gt; ComputeSubmapPose constraint_builder_2d| | | | | | | &gt; NotifyEndOfNode pose_graph_2d.cc:109 ] 4| | | | &gt; AddNode pose_graph_2d.cc:250 ] 6| | | | | | &gt; ComputeConstraintsForNode pose_graph_2d.cc:250 ] 6| | | | | | | &gt; ComputeConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | &gt; MaybeAddGlobalConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | | | &gt; ComputeConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | | | | &gt; Match pose_graph_2d.cc:250 ] 6| | | | | | | | &gt; ComputeConstraintsForOldNodes pose_graph_2d.cc:250 ] 6| | | | | | | | | &gt; ComputeConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | | &gt; MaybeAddGlobalConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | | | &gt; ComputeConstraint pose_graph_2d.cc:250 ] 6| | | | | | | | | | | | &gt; Match]]></content>
  </entry>
  <entry>
    <title><![CDATA[cartographer源码解析]]></title>
    <url>%2Fslam-cartographer-notes%2F</url>
    <content type="text"></content>
      <categories>
        <category>slam技术</category>
      </categories>
      <tags>
        <tag>cartographer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph slam 理论]]></title>
    <url>%2Fslam-GraphSLAM-%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[什么是graph slam推导过程矩阵裁简参考udacity ai-for robots 系列视频306到332 graph slam tutorial : 从推导到应用1 深入理解图优化与g2o：图优化篇 Cartographer的原理探究——GraphSLAM理论基础]]></content>
      <categories>
        <category>slam技术</category>
      </categories>
      <tags>
        <tag>cartographer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[graph slam ceres 实现]]></title>
    <url>%2Fslam-GraphSLAM-ceres%2F</url>
    <content type="text"><![CDATA[本文是graph-slam 理论部分: ceres的实现部分 e = (x_0)^2 + (x_1 - x_0 - 1)^2 + (l_0 - x_0 - 2)^2 + (l_0 - x_1 - 0.8)^2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;vector&gt;#include &lt;iomanip&gt;#include "ceres/ceres.h"#include "gflags/gflags.h"#include "glog/logging.h"using ceres::AutoDiffCostFunction;using ceres::CostFunction;using ceres::Problem;using ceres::Solver;using ceres::Solve;struct F1 &#123; template &lt;typename T&gt; bool operator()(const T* const x1, const T* const x2, T* residual) const &#123; // f1 = x0; residual[0] = x1[0]; return true; &#125;&#125;;struct F2 &#123; template &lt;typename T&gt; bool operator()(const T* const x1, const T* const x0, T* residual) const &#123; // f2 = (x1 - x0 -1.0) residual[0] = x1[0] - x0[0] - 1.0; return true; &#125;&#125;;struct F3 &#123; template &lt;typename T&gt; bool operator()(const T* const l0, const T* const x0, T* residual) const &#123; // f3 = l0 - x0 - 2.0 residual[0] = l0[0] - x0[0] - 2.0; return true; &#125;&#125;;struct F4 &#123; template &lt;typename T&gt; bool operator()(const T* const l0, const T* const x1, T* residual) const &#123; // f4 = lo - x1 - 0.8 residual[0] = l0[0] - x1[0] - 0.8; return true; &#125;&#125;;DEFINE_string(minimizer, "trust_region", "Minimizer type to use, choices are: line_search &amp; trust_region");int main(int argc, char** argv) &#123; CERES_GFLAGS_NAMESPACE::ParseCommandLineFlags(&amp;argc, &amp;argv, true); google::InitGoogleLogging(argv[0]); double x0 = 0.0; double x1 = 1.0; double l0 = 2.0;// double x4 = 1.0; Problem problem; // Add residual terms to the problem using the using the autodiff // wrapper to get the derivatives automatically. The parameters, x0 through // x4, are modified in place. problem.AddResidualBlock(new AutoDiffCostFunction&lt;F1, 1, 1, 1&gt;(new F1), NULL, &amp;x0, &amp;x1); problem.AddResidualBlock(new AutoDiffCostFunction&lt;F2, 1, 1, 1&gt;(new F2), NULL, &amp;x1, &amp;x0); problem.AddResidualBlock(new AutoDiffCostFunction&lt;F3, 1, 1, 1&gt;(new F3), NULL, &amp;l0, &amp;x0); problem.AddResidualBlock(new AutoDiffCostFunction&lt;F4, 1, 1, 1&gt;(new F4), NULL, &amp;l0, &amp;x1); Solver::Options options; LOG_IF(FATAL, !ceres::StringToMinimizerType(FLAGS_minimizer, &amp;options.minimizer_type)) &lt;&lt; "Invalid minimizer: " &lt;&lt; FLAGS_minimizer &lt;&lt; ", valid options are: trust_region and line_search."; options.max_num_iterations = 100; options.linear_solver_type = ceres::DENSE_QR; options.minimizer_progress_to_stdout = true; std::cout &lt;&lt; "Initial x0 = " &lt;&lt; std::setprecision(4)&lt;&lt; x0 &lt;&lt; ", x1 = " &lt;&lt; x1 &lt;&lt; ", l0 = " &lt;&lt; l0 &lt;&lt; "\n"; // Run the solver! Solver::Summary summary; Solve(options, &amp;problem, &amp;summary); std::cout &lt;&lt; summary.FullReport() &lt;&lt; "\n"; std::cout &lt;&lt; "Final x0 = " &lt;&lt; x0 &lt;&lt; ", x1 = " &lt;&lt; x1 &lt;&lt; ", l0 = " &lt;&lt; l0 &lt;&lt; "\n"; return 0;&#125; ceres-solver官网]]></content>
      <categories>
        <category>slam技术</category>
      </categories>
      <tags>
        <tag>cartographer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cartographer 论文翻译]]></title>
    <url>%2Fslam-real-time-loop-closure-in-2d-lidar-slam%2F</url>
    <content type="text"><![CDATA[摘要LIDAR SLAM是获取平面地图的有效方法。 构建便携式捕获平台需要在有限的计算资源下操作。 我们介绍了我们的背包绘图平台中使用的方法，该平台实现了5厘米分辨率的实时构图和闭环。 为了实现实时闭环，我们使用branch-and-bound将扫描到Submap匹配计算为约束。 I. 简介本文的贡献是一种新的方法，用于降低计算激光数据的闭环约束的需求量。 II. 相关工作Scan-to-scan matching经常用于激光SLAM中计算相对姿态变化，例如[1] - [4]。 它的缺点是很快就会累积误差。 Scan-to-map matching有助于限制误差的累积。使用Gauss-Newton在线性插值地图上找到局部最优的一种方法是[5]。在存在良好的位姿初始估计的情况下，在这种情况下通过使用足够高的数据速率LIDAR提供，局部优化的Scan-to-map matching是有效且稳健的。在不稳定的平台上，使用惯性测量单元（IMU）将激光投影到水平面上以估计重力方向。 pixel-accurate scan matching方法，如[1]，进一步减少了局部误差累积。虽然计算上更昂贵，但这种方法对于闭环检测很有用。 一些方法着重于通过匹配激光扫描的提取特征来改善计算成本[4]。其他用于闭环检测方法包括基于直方图的匹配[6]，扫描数据中的特征检测，以及使用机器学习[7]。 解决累积局部误差的两种常用方法是粒子滤波器和基于图形的SLAM [2]，[8]。 基于图形的方法适用于表示位姿和特征的节点集合。 图中的边是由观察产生的约束。 可以使用各种优化方法来最小化由所有约束引入的误差，例如， [11]，[12]。在[13]中描述了这种用于室外SLAM的系统，其使用基于图的方法，局部scan-to-scan匹配，以及基于Submap特征的直方图的重叠局部图的匹配。 III. 系统概述Cartographer可实时室内绘图，生成分辨率为5cm的2D网格地图。 Laser scans被插入到最优估算位姿的Submap中，假定在短时间内足够准确。 而Scan match发生在最近的Submap上，因此它只取决于最近的扫描，全局误差会累积。 cartographer 定期运行位姿优化来减少误差积累。当一个Submap完成时，就不会再将新的扫描插入其中，它将参与Scan match以获得闭环。所有已完成的Submap和扫描都会自动考虑进行闭环。如果它们基于当前的位姿估计足够接近，则Scan match器试图在Submap中找到扫描。如果在当前估计位姿的搜索窗口中找到足够好的匹配，则将其作为闭环约束添加到优化问题。 通过每隔几秒完成一次优化，我们的经验就是当重新访问位置时立即闭环。这导致了软实时约束，即闭环Scan match必须比添加新扫描更快，否则它会明显落后,闭环失败。我们通过对每个完成的Submap使用branch-and-bound和几个预先计算的网格来实现这一点。 IV. 局部2d slam我们的系统将单独的局部和全局方法结合到2D SLAM中。两种方法都优化了由LIDAR观测的（x，y）平移和旋转ξθ组成的姿态ξ=（ξx，ξy，ξθ），其进一步被称为扫描。在不平的地面上，IMU用于估计重力方向，将扫描从水平安装的LIDAR投影到2D世界。在我们的局部方法中，每个连续扫描与Submap相匹配，使用非线性优化将扫描与Submap对齐; 该过程称为real time Scan match,其随着时间累积误差，我们的全局方法将其去除，如第五节所述。 A. ScansSubmap构造是重复对齐scan和Submap坐标帧的迭代过程。随着扫描的原点在$0 \in \Bbb R^2$，我们现在将关于扫描点的信息写为$H = \lbrace h_k\rbrace _{k=1,…,K}, h_k \in \Bbb R^2$。Submap帧中扫描帧的姿态$\xi$表示为变换$T_\xi$，它将扫描点从扫描帧严格转换为Submap帧，定义为 T_\xi = \underbrace{ \left( \begin {matrix} cos\xi_\delta & -sin\xi_\delta \\ sin\xi_\delta & sin\xi_\delta \end{matrix} \right)}_{R_\xi} p + \underbrace{ \left(\begin {matrix} \xi_x \\ \xi_y \end{matrix} \right)}_{t_\xi}. \tag1B. Submaps一些连续扫描用于构建Submap。这些Submap采用概率网格的形式$M : \gamma \Bbb Z × \gamma \Bbb Z \rightarrow [p_{min}, p_{max}]$，它以给定分辨率r的离散网格点进行映射，例如5厘米，到值。这些值可以被认为是网格点被阻挡的概率。对于每个网格点，我们将相应的像素定义为最接近该网格点的所有点。每当要将扫描插入概率网格时，计算用于命中的一组网格点和用于未命中的不相交组。对于每次击中，我们将最近的网格点插入到命中集中。对于每个未命中，我们插入与每个像素相关联的网格点，该网格点与扫描原点和每个扫描点之间的一条光线相交，不包括已经在命中集中的网格点。如果每个以前未观察到的网格点位于其中一个集合中，则会为其分配概率$p_{hit}$ 或 $p_{miss}$。如果已经观察到网格点x，我们更新命中和未命中的几率 odds(p) = \frac{p}{1-p}, \tag1 M_{new}(x) = clamp(odds^{-1}(odds(M_{old}(x))\cdot odds(p_{hit}))) \tag1and equivalently for misses 等同于未命中 C. Ceres scan matching在将扫描插入Submap之前，扫描位姿ξ相对于当前局部Submap进行优化（使用Ceresbased [14]Scan match器）。 扫描匹配器负责在Submap中的扫描点处找到最大概率的扫描位姿。 我们将其视为非线性最小二乘问题 \underset {\xi}{argmin} \sum_{k=1}^K(1-M_(smooth(T_\xi h_k)))^2其中$T\xi$根据扫描位姿将$h_k$从scan帧变换到Submap帧。函数$M_{smooth} : \Bbb R^2 → \Bbb R$是局部Submap中概率值的平滑版本。我们使用双三次插值。结果，可以发生区间$[0, 1]$之外的值，但是被认为是无关紧要的。这种平滑函数的数学优化通常比网格的分辨率提供更好的精度。由于这是局部优化，因此需要良好的初始估计。能够测量角速度的IMU可用于估计Scan match之间的位置的旋转分量$\theta$。虽然计算密集程度更高，但可以在没有IMU的情况下使用更高频率的Scan match或像素精确扫描匹配方法。 V. 闭环由于扫描仅与包含少量最近扫描的Submap匹配，因此上述方法会慢慢累积误差。对于仅几十次连续扫描，累积误差很小。通过创建许多小Submap来处理更大的空间。我们的方法，优化所有扫描和Submap的位姿，遵循稀疏位姿调整[2]。插入扫描的相对位姿存储在内存中，以用于闭环优化。除了这些相对位姿之外，一旦Submap不再发生变化，所有其他由scan和Submap组成的对都被认为是闭环。global scan matcher在后台运行，如果找到良好匹配，则会将相应的相对位姿添加到优化问题中 A. 优化问题闭环优化，和Scan match一样，也被称为非线性最小二乘问题，它允许轻松添加残差以考虑其他数据。每隔几秒钟，我们使用Ceres [14]来计算解决方案 \underset{\Xi ^m,\Xi ^n}{argmin} \frac{1}{2}\sum _{ij}\rho (E^2(\xi _i^m,\xi _j^s;\sigma _{ij},\xi _{ij}))\tag{SPA}在给定一些约束的情况下，Submap构成$\Xi^m = \lbrace\xi_i^m\rbrace_{i=1,…,m}$和世界中的扫描构成$\Xi^s = \lbrace\xi_j^s\rbrace_{j=1,…,n}$被优化。这些约束采用相对位姿$\xi_{ij}$和相关协方差矩阵$\Sigma_ij$的形式。对于一对Submapi和扫描j，位姿ξij描述了Submap坐标系中Scan match的位置。协方差矩阵Σij可以被评估，例如，遵循[15]中的方法，或者局部地使用Ceres [14]与（CS）的协方差估计特征。这种约束的残差E由下式计算 E^2(\xi_i^m, \xi_j^s;\Sigma_{ij},\xi_{ij}) = e(\xi_i^m,\xi_j^s;\xi_{ij})^T\Sigma_{ij}^{-1}e(\xi_i^m,\xi_j^s;\xi_{ij}),\tag4 e(\xi_i^m,\xi_j^s;\xi_{ij}) = \xi_{ij} - \left( \begin{matrix} R_{\xi_i^m}^{-1}(t_{\xi_i^m}-t_{\xi_j^s}) \\ \xi_{ij} - \xi_{j;\theta}^s \end{matrix} \right).\tag5损失函数$\rho$，例如Huber loss，用于减少当Scan match为优化问题添加不正确约束时可能出现在（SPA）中的异常值的影响。例如，这可能发生在局部对称环境中，例如办公室隔间。异常值的替代方法包括[16]。 B. Branch-and-bound scan match我们对最佳的像素精确匹配感兴趣 \xi^* = \underset{\xi\in\omega}{argmax}\sum_{k=1}^kM_{nearest}(T_\xi h_k)),\tag{BBS}其中$\omega$是搜索窗口，$M_{nearest}$是M扩展到所有$\Bbb R^2$，首先将其参数四舍五入到最近的网格点，即将网格点的值扩展为相应的像素。使用（CS）可以进一步提高匹配的质量。 通过仔细选择步长来提高效率。我们选择角度步长$\xi_\theta$，以便最大范围$d_{max}$的扫描点移动不超过$r$，即一个像素的宽度。我们推导出使用余弦定律 d_{max} = \underset{k=1,...,K}{max} \|h_k\|,\tag6 \\ \xi_\theta = arccos(1-\frac{r^2}{2d_max^2})\tag7我们计算了包含给定线性和角度搜索窗口大小的整数步骤，例如$W_x=W_y=7m$和$W_\theta=30\degree$ w_x = \lceil\frac{W_x}{r}\rceil,\ w_y = \lceil\frac{W_y}{r}\rceil,\ w_\theta = \lceil\frac{W_\theta}{\xi_\theta}\rceil.\tag8这导致一个有限的集$W$形成一个围绕估计$\xi_\theta$放置在其中心的搜索窗口， \overline{W} = \{-w_x,...,w_x\} \times \{-w_y,...,w_y\} \times \{-w_\theta,...,w_\theta\}\tag9 W = \{\xi_0 + (rj_x, rj_y, \xi_\theta j_\theta):(j_x,j_y,j_\theta) \in \overline{W}\}\tag{10}找到$\xi^*$的朴素算法很容易制定，参见算法1，但对于搜索窗口大小，我们考虑到它会太慢。 相反，我们使用branch-and-bound在较大的搜索窗口上有效地计算$\xi^*$。有关通用方法，请参见算法2。 这种方法最初是在混合整数线性程序的背景下提出的[17]。关于这个主题的文献很广泛; 见[18]简短概述。主要思想是将可能性子集表示为树中的节点，其中根节点表示所有可能的解决方案，在我们的示例中为$W$。每个节点的子节点形成其父节点的分区，因此它们一起表示同一组可能性。叶节点是单体; 每个代表一个可行的解决方案。请注意，算法是准确的。只要内部节点c的得分（c）是其元素得分的上限，它就提供与朴素方法相同的解决方案。在这种情况下，每当节点有界时，在该子树中不存在比目前最熟知的解决方案更好的解决方案。 为了得到具体的算法，我们必须决定节点选择，分支和上界计算的方法。 1) 节点选择:在没有更好的替代方案的情况下，我们的算法使用深度优先搜索（DFS）作为默认选择：算法的效率取决于被修剪的树的大部分。这取决于两件事：良好的上限和良好的当前解决方案。后一部分由DFS帮助，它可以快速评估许多叶节点。由于我们不希望将不良匹配作为闭环约束添加，我们还引入了一个分数阈值，低于该分数阈值我们对最优解决方案不感兴趣。由于实际上不会经常超过阈值，这降低了节点选择或找到初始启发式解决方案的重要性。关于在DFS期间访问孩子的顺序，我们计算每个孩子的分数的上限，访问具有最大边界的最有希望的子节点。算法3是这种方法。 2) 分支规则：树中的每个节点由整数元组$c=（c_x，c_y，c_θ，c_h）\in\Bbb Z^4$描述。高度为ch的节点最多可合并$2^{ch}\times2^{ch}$可能的翻译，但代表一个特定的轮换： \overline {\overline{W}} = \Bigg(\{j_x,j_y\} \in \Bbb{Z}^2: \\ \Big\lbrace \begin{array}{l} c_x \leq j_x < c_x + 2^{ch} \\ c_x \leq j_x < c_x + 2^{ch} \end{array} \Big\rbrace \times \lbrace c_\theta \rbrace \Bigg) ,\tag{11} \overline{W}_c = \overline{\overline{W}} \cap \overline{W}\tag{12} 叶节点具有高度$c_h=0$，并且对应于可行解$W\ni\xi_c=\xi_0 +（rc_x，rc_y，\xi_\theta c_\theta）$。 在我们的算法3的公式中，包含所有可行解的根节点没有明确地出现并且分支到一组初始节点$C_0$，在固定高度$h_0$覆盖搜索窗口 \overline{W}_{0,x} = \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\ \overline{W}_{0,x} = \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\ \overline{W}_{0,x} = \lbrace -w_x + 2^{h_o}:j_x \in \Bbb Z, 0 \leq 2^{h_o} \leq 2w_x \rbrace, \\ C_0 = \overline{W}_{0,x} \times \overline{W}_{0,y} \times \overline{W}_{0,\theta} \times \{h_0\}. \tag{13}At a given node c with $c_h &gt; 1$, we branch into up to four children of height $c_h − 1$在$c_h&gt;1$的给定节点c，我们分支最多四个子高度$c_h − 1$ C_c = ((\{c_x,c_x + 2^{c_h-1}\} \times {c_y, c_y + 2^{c_h-1} \times c_\theta}) \cap \overline{W}) \times \{c_h-1\}\tag{14}3) 计算上界：分支和边界方法的剩余部分是计算内部节点上限的有效方式，包括计算工作量和边界质量。我们用 score(c) = \sum_{k=1}^{K}\underset{j\in \overline{\overline{W_c}}}{max}M{nearest}(T\xi_jh_k) \\ \geq\sum_{k=1}^{K}\underset{j\in \overline{W_c}}{max}M_{nearest}(T\xi_{j}h_{k})\\ \underset{j\in \overline{W_c}}{max}\sum_{k=1}^{K}maxM_{nearest}(T\xi_{j}h_{k})\tag{15}为了能够有效地计算最大值，我们使用预先计算的网格$M_{precomp}^{ch}$。每个可能的高度$c_h$预先计算一个网格允许我们用扫描点数的effor linear计算得分。请注意，为了能够执行此操作，我们还计算了超过$\overline{\overline{W_c}}$的最大值，该值可能大于我们搜索空间边界附近的$\overline{W_c}$。 score(c) = \sum_{k=1}^{K}M_{precomp}^{ch}(T\xi_{c}h_{k})\tag{16} M_{precomp}^{ch}(x,y) = \underset {\begin{matrix} x^, \in [x,x+r(2^h-1)] \\ y^, \in [y,y+r(2^h-1)] \end{matrix}} {max} M_{nearest}(x^, , y^,) \tag{17}与叶节点一样使用$\xi_c$。请注意，Mhprecomp与$M_{nearest}$具有相同的像素结构，但在每个像素中存储从那里开始的$2^h\times 2^h$像素值的最大值。图3给出了这种预先计算的网格的一个例子。 为了使构建预先计算的网格的计算工作量保持在较低水平，我们要等到概率网格不再接收更新。然后我们计算一组预先计算的网格，并开始匹配它。 对于每个预先计算的网格，我们计算从每个像素开始的$2^h$像素宽行的最大值。使用该中间结果，然后构造下一个预先计算的网格。 如果按照添加顺序删除值，则可以按摊销$O（1）$保持更改值集合的最大值。连续最大值保存在一个双端队列中，可以递归地定义为包含当前在集合中的所有值的最大值，然后是在第一次出现最大值之后所有值的连续最大值列表。对于空的值集合，此列表为空。使用此方法，可以在$O（n）$中计算预先计算的网格，其中n是每个预先计算的网格中的像素数。 计算上限的另一种方法是计算较低分辨率的概率网格，连续减半分辨率，见[1]。由于我们的方法的额外内存消耗是可接受的，我们更喜欢使用较低分辨率的概率网格，这导致比（15）更差的界限，从而对性能产生负面影响。 参考[1] E. Olson，M3RSM：多对多分辨率Scan match，载于IEEE国际机器人与自动化会议论文集（ICRA），2015年6月。 [2] K. Konolige，G。Grisetti，R。Kummerle，W。Burgard，B。Limketkai，¨和R. Vincent，`稀疏位姿调整2D绘图`，在IROS，台湾台北，2010年10月10日。 [3] F. Lu和E. Milios，用于环境绘图的全局一致范围扫描对准，自主机器人，第一卷。 4，不。 4，pp.333- 349,1997。 [4]F.Mart’ın，R。Triebel，L。Moreno和R. Siegwart，两种不同的三维构图工具：基于DE的Scan match和基于特征的环路检测，Robotica，vol。 32，不。 01，pp.19-41,2014。 [5] S. Kohlbrecher，J。Meyer，O。von Stryk和U. Klingauf，具有完整3D运动估计的灵活且可扩展的SLAM系统，Proc。 IEEE国际安全，安全和救援机器人研讨会（SSRR）。 IEEE，2011年11月。 [6] M. Himstedt，J。Frost，S。Hellbach，H.-J。 Bohme和E. Maehle，使用几何地标关系的2D LIDAR扫描中的大规模地点识别，智能机器人和系统（IROS 2014），2014年IEEE / RSJ国际会议。 IEEE，2014，pp.5030-5035。 [7] K. Granstrom，T。B.Sch¨on，J.I。Nieto和F. T. Ramos，学习close闭合范围数据循环，国际机器人研究杂志，第一卷。 30，不。 14，pp.1728-1754,2011。 [8] G. Grisetti，C。Stachniss和W. Burgard，通过自适应提议和选择性重采样改进基于网格的SLAM与Rao-Blackwellized粒子滤波器，机器人与自动化，2005年.ICRA 2005. 2005年会议记录IEEE国际会议。 IEEE，2005，pp.2432-2437。 [9] G. D. Tipaldi，M。Braun和K. O. Arras，FLIRT：2D范围数据的兴趣区域，应用于机器人导航，在实验机器人中。 Springer，2014年，第695-710页。]]></content>
      <categories>
        <category>slam技术</category>
      </categories>
      <tags>
        <tag>cartographer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Algorithms-notes]]></title>
    <url>%2Falgorithms-notes%2F</url>
    <content type="text"></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>algo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静脉曲张的原理和治疗方法]]></title>
    <url>%2Flife-Varicose-veins%2F</url>
    <content type="text"><![CDATA[概述静脉曲张形成的主要原因是由于先天性血管壁膜比较薄弱或长时间维持相同姿势很少改变，血液蓄积下肢，在日积月累的情况下破坏静脉瓣膜而产生静脉压过高，使血管突出皮肤表面的症状。 改善方法物理治疗: 弹力袜1.1 弹力袜促进血液回流: 为什么有用?: 弹力袜在腿上的压力不一样，利用这种压力梯度可以促进血液回流。 注意： 但不是所有的人都适合穿弹力袜，静脉曲张较严重的患者穿弹力袜之前最好咨询医生。 1.2 按摩加速血液循环:在腿部感到疲劳时，或者平时方便的时候对腿部进行简单的揉捏，加速血液循环。 注意：坚持下来，静脉曲张就可以得到有效的改善.至于按摩可以改善血液循环的原理其实并不是很有科学依据，知乎上还是能找到一些,但是找不到靠谱的解释，本人实践过，确实是没有什么改善,不过也有可能是按摩手法的不对。网上找了能够促进血液循环的按摩方法.静脉曲张按摩手法 运动加强静脉管壁从血液动力学的角度进行观察，健康的人在运动时，由于瓣膜的功能正常，肌肉的规律性收缩使得深部静脉血液回流加速，皮下静脉的压力甚至可能比静止时还低。所以进行适当的跑步锻炼，不但不会引起下肢静脉曲张，恰恰相反，跑步可以使腿部肌肉活动增强，挤压静脉内的血液，使其流动更加顺畅，还有助于预防和改善下肢静脉曲张。对于静脉曲张的患者来说，当然也可以进行如慢跑、游泳、单车、跳绳等运动。但是因为静脉瓣膜功能受损，应当避免像举重、快速冲刺短跑、跳远、投掷等引起腹压增高的活动。 注意:但是严重的静脉曲张患者，不要一下子运动过量，否则容易对心血管造成伤害。 食疗 多食用蔬菜、水果、豆类等纤维素含量较高的食物，适量食用瘦牛肉、鸡肉等，多吃含维E的食物，如洋白菜、菠菜、橙子等可以疏通经络，改善血液循环，减轻腿部的沉重感。 1、在静脉曲张的饮食中新鲜蔬菜和水果不能少：新鲜蔬菜和水果含有大量的维生素及矿物质，可以改善组织的氧化作用，增加血液循环，提高机体免疫力。如新鲜水果中含有大量维生素 C ，可以通过降低血凝倾向，改善血液循环，促进康复，预防淤伤。新鲜蔬菜含有丰富纤维素，能避免便秘，保持肠道清洁，改善肛周围的血液循环，预防末梢静脉曲张和痔疮的形成。 2、要有足够的蛋白质：静脉曲张的饮食中要多含蛋白质丰富的食物，如鱼、牛、羊肉等，大豆以及豆制品也含有丰富的植物蛋白，也应多吃。充足的蛋白质可以维持体内所有营养物质的平衡，增强免疫力，保护细胞，还可以乳化脂肪，促进血液循环。 3、含维生素 E 丰富的食物：静脉曲张的饮食要多含维生素E的食物，可以改善血液循环，减轻腿部的沉重感。含维生素 E 丰富的食物有：洋白菜、菠菜、甘蓝、麦芽、坚果类、大豆、全麦、粗粮、蛋等都是静脉曲张的饮食注意事项。 如何预防预防的扎6招防小腿静脉曲张 睡前抬腿久站抬脚尖 1. 睡前抬腿 2. 久站抬脚尖静脉曲张的成因是静脉瓣膜功能不良，静脉血液向下逆流而形成静脉曲张。因此，站立时，要每隔一段时间就抬脚尖，让肌肉收缩，给静脉血液加压，让血液往心脏方向流动，致使静脉瓣膜打开维持正常功能。一般来说，小腿感到酸麻时，就是在提醒你要抬脚尖了。 3. 穿平跟鞋平跟鞋有助于预防静脉曲张，在体育锻炼时一定要穿有海绵垫的运动鞋或旅游鞋，对缓解腿部压力，预防静脉曲张很有帮助。 4. 赤足在条件允许的情况下，下班回家后，将鞋脱掉，赤足或穿拖鞋行走，可以改善足部血液循环，并使足部肌肉得到锻炼。 5. 抬高下肢站立工作者在工间休息时，宜将鞋脱掉，双脚抬高，足部要高于心脏30厘米以上，下班回到家中后也应将双脚抬高15分钟，缓解血液对下肢的压力。 6. 改掉不良如厕习惯在上厕所时看书报，这是很不好的生活习惯。上厕所时看书报，蹲踞时间长会给下肢静脉增加过多的负担，造成血管内滞血，因此这种习惯一定要改掉。 装备:1. 弹力袜子使用 起床穿。 睡觉不穿。 半年换。最好三个月，看物料和生活习惯。因为弹性会不断下降，没弹性等于没压力，所以穿鬆了就要换。 手洗＋不晒太阳＋摊乾＋不用化学清洗剂(柔顺／漂白)可以让弹性保持久一点，这个就看自己勤不勤快了。 最重要的一点，运动。简单说就是让下肢肌肉更好的泵血，更好的把血从下肢输送回心脏，另外也可以避免和减少长期穿压力袜后依赖和股肉无力的情况。 选择型号 根据穿者的腿部症状选择合适的静脉曲张袜压力。静脉曲张袜分为以下几级压力：一级低压预防保健型(15-25mmHg)：适用于静脉曲张、血栓高发人群的保健预防;一级中压初期治疗型(25-30mmHg)：适用于静脉曲张初期患者;二级高压中度治疗型(30-40mmHg)：适用于下肢已经有明显的静脉曲张(站立时静脉血管凸出皮肤表面)，并伴有腿部不适感的患者(如下肢酸乏肿胀、湿疹瘙痒、抽筋发麻、色素沉着等)、静脉炎、怀孕期间严重静脉曲张、静脉曲张手术后(大小隐静脉剥脱术)患者、深静脉血栓形成后综合症患者;三级高压重度治疗型(40-50mmHg)：适用于下肢高度肿胀、溃疡、皮肤变黑变硬、高度淋巴水肿、整形抽脂术后恢复期等患者。 根据病变部位选择静脉曲张袜的长度。中统袜(膝下)、长统袜(及大腿)、连裤袜(及腰部)。如果穿者只是膝盖以下的部位患有静脉曲张，穿中统静脉曲张袜即可;如果穿者膝盖以上的部位也有症状、需要穿长统的或者连裤型静脉曲张袜。 确定合适的号型(静脉曲张袜分为小号S、中号M、大号L、加大号XL)。量出穿者腿部的三个主要尺寸(厘米)：脚踝(脚脖子最细处)周长、小腿肚最大周长及大腿最大周长，以确定合适的号码，购买连裤袜要根据穿者的身高体重选择号码。 注意: 如何判断自己的静脉曲张严重程度国际上，静脉曲张按照程度不同共分为0-6期： c1: 表层血管像蚯蚓一样曲张，明显凸出皮肤，曲张呈团状或结节状，有毛细血管扩张、网状静脉、踝部潮红。c2: 在站立时腿部可见弯曲增粗的表浅静脉血管，高出皮肤，在腿部抬高或平卧后可消失，常有小腿酸胀、易疲劳等不适感觉，此期是治疗的较好时期。c3: 曲张血管增多，小腿开始出现水肿，以站立过久或劳累后较明显，晨起时水肿可消退。患肢常比对侧腿增粗，有些人还出现皮肤瘙痒，严重者呈现湿疹、瘀积性皮炎等皮肤病变。c4: 血管内血液瘀积过多，静脉压力明显增高，使一部分血液成分渗透至血管外的皮肤及皮下组织，造成局部皮肤发红，变紫，直至发黑(血中铁元素沉积)，并且失去弹性而变硬。c5: 已发展为急性溃疡期，发黑变硬的皮肤在外力作用下发生破溃，采用普通方法已很难康复，严重影响工作与生活。c6: 静脉曲张晚期，或未经正确治疗的静脉性溃疡反复发作，形成臁疮腿，常见于踝关节附近及小腿下段，俗称“老烂腿”。 一级压力裤: c1 二级压力裤: c2-c4 三级压力裤: c4*c6 去哪里买 国内压力袜是属于医疗器械，不是哪都可以卖的，如果不是正规的地方卖的，大概率不是真的 上外国网站自己买，因为国内压力袜是属于医疗器械，如果有代购或是什麽海淘，如果不是正规的医疗器械卖家，性质像偷卖外国药一样。 排行版]]></content>
      <categories>
        <category>生活相关</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[封闭阳台]]></title>
    <url>%2Flife-Closed-balcony%2F</url>
    <content type="text"><![CDATA[概述一般封闭阳台由三部分构成 框窗:建议安装有框 气密窗，最好是经过抗压性、气密性（刮风的时候不会有灰尘钻进来）和水密性（下雨的时候不会有水流到室内）检验的。 注意： 气密性能: 120等级、30等级、8等级、2等级影响因素: 窗户框扇的搭接处、气密防水胶条和毛刷条长度、内扇窗的气密橡胶条与内扇下支长度，毛刷条的完整性，玻璃压条与玻璃长度 玻璃 钢化玻璃隔音保温表现更好的双层中空玻璃 防护栏 框窗框窗类型有很多，铝合金门窗、实木窗、铝木复合窗、玻璃钢门窗、不锈钢门窗、无框窗 塑钢门窗优点是隔音、隔热防火保温，气密性、水密、防腐都不错，而且价格便宜。缺点是它的断面较大，比起铝合金窗来说采光性略差。 铝合金门窗优点: 硬度高，不易刮伤，耐磨耐候，表面光滑，耐污性佳便于清洁。而且价格便宜。缺点: 是导热性强，保温性差。 断桥铝合金优点: 结合上面两种缺点: 最贵 -玻璃门窗（也叫无框窗）优点:采光性良好、空气流通好、美观易折叠等。缺点:保温性差，密封性差，隔音一般。 价格塑钢窗的价格塑钢窗主材价格:每种品牌的塑钢窗主材价格不同,如海螺型材现在的价格是10500元/吨,每吨的出窗率要看窗的型号,88推拉窗估计能出95-100平米,80的推拉窗能出100-105平米,60平开窗能出70-75平米左右,按面积计算,也就是88的型材成本价格为110-105元,80的型材成本价格为105-100元,60的型材成本合到150-140元。 塑钢窗五金配件价格:推拉窗要用到的滑轮和月牙锁,这两个加起来的价格为8元/平米,还有就是密封毛条和减震胶条,加起来价格为10元/平米,再就是制作和安装要30元/平米,另外运输要4元/平米。 塑钢窗加强钢价格:主材里要有加强钢,市场价格是4000左右/吨,如果用的是1.2的话要成本20元左右,低于这个标准的1.0以下的可能有12元左右就可以了。 塑钢窗玻璃价格:市场上的玻璃有浮法、格法、平板等几种,浮法的5毫米的玻璃价格30元,格法的24元,平板的19元。如果用中空玻璃的话,除了加一层玻璃的钱还要用到铝合金的框架和干燥外围的中空胶,这些的成本价格是10-15元。 塑钢窗密封处理价格:主要是打泡沫胶和密封胶,价格要看窗台的平整情况,好的窗台有5元/米就可以,旧的窗台由于拆旧窗的破坏会用到12元/米左右。 88推拉窗 110 型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=212元/平米。 80推拉窗 105型材+五金8+配件10+制作安装30+20加强钢+玻璃30+运输4=207元/平米。 60平开窗 150型材+五38+配件10+制作安装30+20加强钢+玻璃30+运输4=284元/平米。 铝合金窗的价格铝合金普通推拉窗的价格在250元/平方米左右,采用1.2mm厚标准铝型材,单片5mm玻璃;铝合金隔音隔热窗750元/平方米左右,采用1.4厚铝型材,中空玻璃。 铝合金窗主材价格差别很大,铝材的价格主要差别在铝材的质量上,有厚薄优劣之分,一般氧化铝材160元/平米,电泳铝材200元/平方左右,彩色铝材260元/平米以上。铝型材质有50系列、55系列、60系列、70系列等,其中50系列的铝材价格在400元/平米左右,而70系列铝材价格可达到700元/平米,不同系列的铝材质厚度不一样,铝材越厚的窗户价格越高。 以上是塑钢窗和铝合金窗的价格介绍,塑钢窗因为用得比较多,大家对它的价格很熟悉。铝合金窗低档的没人愿意用,宁可用塑钢窗代替,高档铝合金窗价格又很高,常用于施工要求较高的建筑或高档建筑。]]></content>
      <categories>
        <category>生活相关</category>
      </categories>
      <tags>
        <tag>阳台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python笔记]]></title>
    <url>%2Flanguage-python-notes%2F</url>
    <content type="text"></content>
      <categories>
        <category>语言相关</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在vscode jupyter模式下工作]]></title>
    <url>%2Ftools-work-in-vscode-with-jupyter%2F</url>
    <content type="text"><![CDATA[概述使用jupyter notebook工作时候不习惯，自己还是喜欢在vscode纯vim的工作模式。于是下载了vscode jupyter的插件，但是这是来写pyd代码的。我的目的最终是生成md文档，记录我学习的过程。于是我下载了一个py2md.py的工具。做了些修改，用于把py生成md文件。 1234567891011#! /usr/bin/env pythonimport sysimport itertoolsfor markdown, lines in itertools.groupby(open(sys.argv[1]).readlines(), key=lambda line: line.startswith('# ')): if markdown: print(''.join(line[2:] for line in lines)) else: print('\n```python') print(''.join(lines).strip()) print('```\n') 写的过程中需要注意的几点: 文档直接用＃ 隔开，并且不要留有空格# # 文档直接用＃ 隔开，并且不要留有空格 标题上下用# ， 看起来更清晰## ####我是标题# python文档的代码用＃％％是表示执行cell的#%%python文档的代码用＃％％是表示执行cell的 输出结果用不带空格的#表示#输出 使用vscode 的tasks可以快速的执行python命令添加任务的做法可见vscode 文档 更新vscode 下安装的插件 github]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[notes-python]]></title>
    <url>%2Flanguage-notes-python%2F</url>
    <content type="text"><![CDATA[概述中文 Python 笔记这是个学习python的好资料,用神器jupyter写的。而我的目的是jupyter来阅读不如用docsify阅读来的方便， 幸运的是作者已经写了个脚本，用这个脚本可以快速的转换,所以我做了写修改，直接生成md文件。 下载 1git clone https://github.com/lijin-THU/notes-python.git 生成md文件 1python generate_static_files.py 提交到note-python的docs的docs文件,并设为个人博客的子目录 个人博客创建 notes-python文档 ab abc 你好吗这是一个我很好 概述 你好吗 这是一个 我很好]]></content>
      <categories>
        <category>语言相关</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些神奇的工具使用笔记]]></title>
    <url>%2Ftools-youtube-dl%2F</url>
    <content type="text"><![CDATA[youtube-dl概述这是一个可以下载youtube视频和字幕的神奇工具，我主要用于下载字幕.使用这个的前提是你得翻墙。 安装1pip install --upgrade youtube-dl 常用命令youtube-dl有很多参数，我就不一一介绍。运行youtube -h可以查看所有命令,这里列出我用到的一些命令: 注意:由于众所周知的原因，使用之前需要下载proxychains,1sudo apt-get install proxychains 安装proxychains,需要修改/etc/proxychains配置最后一行12# socks4 127.0.0.1 9050socks5 127.0.0.1 1080 1080是你翻墙的端口 1proxychains youtube-dl --write-sub --sub-lang en --skip-download -o "%(playlist_index)s-%(title)s.%(ext)s" "https://www.youtube.com/playlist?list=PLAwxTw4SYaPkCSYXw6-a_aAoXVKLDwnHK" youtube-dl —list-subs —no-playlist “https://youtu.be/nLEbJZFm5-E?list=PLAwxTw4SYaPkCSYXw6-a_aAoXVKLDwnHK “选项的解释 —write-sub: 写到字幕文件 —sub-lang: 下载语言 —skip-download: 不下载视频 -o “%(playlist_index)s-%(title)s.%(ext)s” : 使用编号加标题 notedownnotedown主要是用来实现md to ipynb，这样我就可以直接一边写博客一边调试代码。使用方法如下: 安装: 1pip install https://github.com/aaren/notedown/tarball/master 打开文件: 1sudo gedit ~/.jupyter/jupyter_notebook_config.py ` 增加以下内容，存盘 c.NotebookApp.contents_manager_class = ‘notedown.NotedownContentsManager’ 重启jupyter notebook 服务]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>youtube-dl</tag>
        <tag>proxychains</tag>
        <tag>notedown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机视觉入门]]></title>
    <url>%2Fcomputer-vision-Introduction%2F</url>
    <content type="text"></content>
      <categories>
        <category>机器视觉</category>
      </categories>
      <tags>
        <tag>udacity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu环境搭建脚本]]></title>
    <url>%2Ftools-linux-config%2F</url>
    <content type="text"><![CDATA[使用阿里云存储软件和私有代码阿里云code code.aliyun.com概述 单个project的存储上限是1G 每个帐号创建的仓库数不能超过50个。 安装 chrome123wget https://code.aliyun.com/lsy5631932/software/blob/6ac1f060ddca3ee5a099686d994664c64a309c36/google-chrome-stable_current_amd64.debsudo dpkg -i ./google-chrome-stable_current_amd64.debrm google-chrome-stable_current_amd64.deb switchomiga安装ssl安装 git123sudo apt-get install gitgit config --global user.email &quot;you@example.com&quot;git config --global user.name &quot;Your Name&quot; 安装 Node.js12345wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | shecho &quot;export NVM_DIR=&quot;$HOME/.nvm&quot;&quot; &gt;&gt; ~/.zshrcsource ~/.zshrc[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;nvm install stable 安装 Hexo12npm install -g hexo-clinpm install hexo --save 安装 docsify1npm i docsify-cli -g tmux1sudo apt-get install tmux -y 设置shell为zshrc12sudo apt-get install zsh -ychsh -s /bin/zsh 安装oh my zsh1wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh 切换caps to ctrl12echo &quot;setxkbmap -layout us -option ctrl:nocaps&quot; &gt;&gt; ~/.zshrcsource ~/.zshrc 模糊搜索神器fzf123git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf~/.fzf/installsource ~/.zshrc autojump12345git clone git://github.com/joelthelion/autojump.git ~/.autojump~cd ~/.autojump~./install.py[[ -s /home/syue/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; source /home/syue/.autojump/etc/profile.d/autojump.shautoload -U compinit &amp;&amp; compinit -u install ros12345678910sudo sh -c &apos;echo &quot;deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main&quot; &gt; /etc/apt/sources.list.d/ros-latest.list&apos;sudo apt-key adv --keyserver hkp://ha.pool.sks-keyservers.net:80 --recv-key 421C365BD9FF1F717815A3895523BAEEB01FA116sudo apt-get updatesudo apt-get install ros-kinetic-desktop-fullapt-cache search ros-kineticsudo rosdep initrosdep updateecho &quot;source /opt/ros/kinetic/setup.zsh&quot; &gt;&gt; ~/.zshrcsource ~/.zshrcsource /opt/ros/kinetic/setup.zsh install clioninstall docker1234curl -fsSL get.docker.com -o get-docker.shsudo sh get-docker.sh --mirror Aliyunsudo groupadd dockersudo usermod -aG docker $USER]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[打造Hexo个人博客]]></title>
    <url>%2Ftools-hexo-note%2F</url>
    <content type="text"><![CDATA[配置Hexo渲染MathJax数学公式，推荐文章：https://www.jianshu.com/p/7ab21c7f0674 经历了几天的努力，终于解决了几个重大问题，打造出自己理想的博客个人网站。主要是参照大黄菌的个人博客,但是她没有公布使用如何使用hexo跳转到docsify的步骤。现在把我这几天填过的坑记下来。 首先说下我的需求: hexo作博客,next作主题. 可以自动跳转到docsify文档的界面. 使用个人域名 支持mathjax hexo作博客,next作主题hexo作博客使用hexo构建博客主要是参照hexo的官方文档.以下是构建的步骤: 开始使用 概述: 安装: post_asset_folder: true 注意: npm 必须使用sudo 建站: npm install这条指令有什么用 package.json 的文档内容现在有不明白有什么用 scaffolds: 默认post,draft是草稿模板，page是页面模板，当你使用tag,category的时候用到，后面会讲到 source: _文件隐藏，Markdown,html解析，其他拷贝过去。如拷贝CNAME themes:主题，next就是拷贝到这里的 配置: 网站: title ,就是浏览器标签栏的名字，subtitle 网页显示的Hexo首页的地方. 注意：必须hexo serve重启才能生效 网址: 网站存放在子目录,目前不用 目录: 目前不用 文章: titlecase指的是将每个单词首字母转换成大写,post_asset_folder: true 分类 &amp; 标签: 不用到 日期 / 时间格式: 不用到 分页 不用到: 扩展: theme: ,现在不用，但是后面改为next要回来改 deploy 最好现在就布置，自动发布到github,之前没有看到这个选项，手动发布. 注意: 这是我的设置type: gitrepo: git@github.com:lsy563193/lsy563193.github.io.gitbranch: master 指令: init, new, generate, deploy, publish ,server 注意:hexo g -d, hexo d -g 通常用,一样的hexo serve 也是可以简写为hexo s的，不用加路径，常用 迁移 基本操作 写作 Front-matter开启了 comments 评论功能 预先定义的参数 分类和标签 注意:categories: Diary Life会使分类Life成为Diary的子分类 标签插件在markdown 中添加太多的hexo 标签，其实会在以后用其他编辑器预览，查看，迁移时留下诸多不变，毕竟，私有的语法意味着不兼容 资源文件夹资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。 数据文件 服务器 生成器 部署自定义 永久链接 可以自动跳转到docsify文档的界面实现的方式是使用域名覆盖。以链接到吴恩达《深度学习》系列课程笔记,为例,网址为http://lsy563193/github.io/Andrew-Ng-Deep-Learning-notes/ ,我们只要让page的网址也为这个，这样在点击的时候就自动替换为 Andrew-Ng-Deep-Learning-notes的内容实现的步骤如下: 克隆:克隆Andrew-Ng-Deep-Learning-notes到你的github目录， 设置为github.io的doc目录: 把这个项目设置为你博客下的目录 把hexo生成的地址也设置为这个: 首先创建Andrew-Ng-Deep-Learning-notes的博文 1hexo new Andrew-Ng-Deep-Learning-notes 设置category,比如为深度学习笔记,效果如下 设置_config.yml的permalink: :title/: 这样两者的地址就一样的 Hexo-Next-主题优化参考 浏览页面的时候显示当前浏览进度_config.yml scrollpercent 开启版权声明主题配置文件下,搜索关键字post_copyright,enable改为true 主题]]></content>
      <categories>
        <category>环境搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
